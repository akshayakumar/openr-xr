#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import six
from thrift.util.Recursive import fix_spec
from thrift.Thrift import *
from thrift.protocol.TProtocol import TProtocolException


import openr.IpPrefix.ttypes
import openr.Lsdb.ttypes


import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
try:
  from thrift.protocol import fastproto
except:
  fastproto = None
all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'FibCommand', 'Path', 'Route', 'RouteDatabase', 'PerfDatabase', 'FibRequest']

class FibCommand:
  ROUTE_DB_GET = 1
  PERF_DB_GET = 2

  _VALUES_TO_NAMES = {
    1: "ROUTE_DB_GET",
    2: "PERF_DB_GET",
  }

  _NAMES_TO_VALUES = {
    "ROUTE_DB_GET": 1,
    "PERF_DB_GET": 2,
  }

class Path:
  """
  Attributes:
   - nextHop
   - ifName
   - metric
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.nextHop = openr.IpPrefix.ttypes.BinaryAddress()
          self.nextHop.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ifName = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.metric = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Path')
    if self.nextHop != None:
      oprot.writeFieldBegin('nextHop', TType.STRUCT, 1)
      self.nextHop.write(oprot)
      oprot.writeFieldEnd()
    if self.ifName != None:
      oprot.writeFieldBegin('ifName', TType.STRING, 2)
      oprot.writeString(self.ifName.encode('utf-8')) if UTF8STRINGS and not isinstance(self.ifName, bytes) else oprot.writeString(self.ifName)
      oprot.writeFieldEnd()
    if self.metric != None:
      oprot.writeFieldBegin('metric', TType.I32, 3)
      oprot.writeI32(self.metric)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.nextHop, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    nextHop=%s' % (value))
    value = pprint.pformat(self.ifName, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    ifName=%s' % (value))
    value = pprint.pformat(self.metric, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    metric=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class Route:
  """
  Attributes:
   - prefix
   - paths
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.prefix = openr.IpPrefix.ttypes.IpPrefix()
          self.prefix.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.paths = []
          (_etype3, _size0) = iprot.readListBegin()
          if _size0 >= 0:
            for _i4 in six.moves.range(_size0):
              _elem5 = Path()
              _elem5.read(iprot)
              self.paths.append(_elem5)
          else: 
            while iprot.peekList():
              _elem6 = Path()
              _elem6.read(iprot)
              self.paths.append(_elem6)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Route')
    if self.prefix != None:
      oprot.writeFieldBegin('prefix', TType.STRUCT, 1)
      self.prefix.write(oprot)
      oprot.writeFieldEnd()
    if self.paths != None:
      oprot.writeFieldBegin('paths', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.paths))
      for iter7 in self.paths:
        iter7.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.prefix, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    prefix=%s' % (value))
    value = pprint.pformat(self.paths, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    paths=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class RouteDatabase:
  """
  Attributes:
   - thisNodeName
   - routes
   - perfEvents
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.thisNodeName = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.routes = []
          (_etype11, _size8) = iprot.readListBegin()
          if _size8 >= 0:
            for _i12 in six.moves.range(_size8):
              _elem13 = Route()
              _elem13.read(iprot)
              self.routes.append(_elem13)
          else: 
            while iprot.peekList():
              _elem14 = Route()
              _elem14.read(iprot)
              self.routes.append(_elem14)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.perfEvents = openr.Lsdb.ttypes.PerfEvents()
          self.perfEvents.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('RouteDatabase')
    if self.thisNodeName != None:
      oprot.writeFieldBegin('thisNodeName', TType.STRING, 1)
      oprot.writeString(self.thisNodeName.encode('utf-8')) if UTF8STRINGS and not isinstance(self.thisNodeName, bytes) else oprot.writeString(self.thisNodeName)
      oprot.writeFieldEnd()
    if self.routes != None:
      oprot.writeFieldBegin('routes', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.routes))
      for iter15 in self.routes:
        iter15.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.perfEvents != None:
      oprot.writeFieldBegin('perfEvents', TType.STRUCT, 3)
      self.perfEvents.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.thisNodeName, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    thisNodeName=%s' % (value))
    value = pprint.pformat(self.routes, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    routes=%s' % (value))
    value = pprint.pformat(self.perfEvents, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    perfEvents=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class PerfDatabase:
  """
  Attributes:
   - thisNodeName
   - eventInfo
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.thisNodeName = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.eventInfo = []
          (_etype19, _size16) = iprot.readListBegin()
          if _size16 >= 0:
            for _i20 in six.moves.range(_size16):
              _elem21 = openr.Lsdb.ttypes.PerfEvents()
              _elem21.read(iprot)
              self.eventInfo.append(_elem21)
          else: 
            while iprot.peekList():
              _elem22 = openr.Lsdb.ttypes.PerfEvents()
              _elem22.read(iprot)
              self.eventInfo.append(_elem22)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('PerfDatabase')
    if self.thisNodeName != None:
      oprot.writeFieldBegin('thisNodeName', TType.STRING, 1)
      oprot.writeString(self.thisNodeName.encode('utf-8')) if UTF8STRINGS and not isinstance(self.thisNodeName, bytes) else oprot.writeString(self.thisNodeName)
      oprot.writeFieldEnd()
    if self.eventInfo != None:
      oprot.writeFieldBegin('eventInfo', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.eventInfo))
      for iter23 in self.eventInfo:
        iter23.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.thisNodeName, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    thisNodeName=%s' % (value))
    value = pprint.pformat(self.eventInfo, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    eventInfo=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class FibRequest:
  """
  Attributes:
   - cmd
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cmd = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('FibRequest')
    if self.cmd != None:
      oprot.writeFieldBegin('cmd', TType.I32, 1)
      oprot.writeI32(self.cmd)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.cmd, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    cmd=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(Path)
Path.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'nextHop', [openr.IpPrefix.ttypes.BinaryAddress, openr.IpPrefix.ttypes.BinaryAddress.thrift_spec, False], None, 2, ), # 1
  (2, TType.STRING, 'ifName', True, None, 2, ), # 2
  (3, TType.I32, 'metric', None, None, 2, ), # 3
)

Path.thrift_struct_annotations = {
}
Path.thrift_field_annotations = {
}

def Path__init__(self, nextHop=None, ifName=None, metric=None,):
  self.nextHop = nextHop
  self.ifName = ifName
  self.metric = metric

Path.__init__ = Path__init__

all_structs.append(Route)
Route.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'prefix', [openr.IpPrefix.ttypes.IpPrefix, openr.IpPrefix.ttypes.IpPrefix.thrift_spec, False], None, 2, ), # 1
  (2, TType.LIST, 'paths', (TType.STRUCT,[Path, Path.thrift_spec, False]), None, 2, ), # 2
)

Route.thrift_struct_annotations = {
}
Route.thrift_field_annotations = {
}

def Route__init__(self, prefix=None, paths=None,):
  self.prefix = prefix
  self.paths = paths

Route.__init__ = Route__init__

all_structs.append(RouteDatabase)
RouteDatabase.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'thisNodeName', True, None, 2, ), # 1
  (2, TType.LIST, 'routes', (TType.STRUCT,[Route, Route.thrift_spec, False]), None, 2, ), # 2
  (3, TType.STRUCT, 'perfEvents', [openr.Lsdb.ttypes.PerfEvents, openr.Lsdb.ttypes.PerfEvents.thrift_spec, False], None, 1, ), # 3
)

RouteDatabase.thrift_struct_annotations = {
}
RouteDatabase.thrift_field_annotations = {
}

def RouteDatabase__init__(self, thisNodeName=None, routes=None, perfEvents=None,):
  self.thisNodeName = thisNodeName
  self.routes = routes
  self.perfEvents = perfEvents

RouteDatabase.__init__ = RouteDatabase__init__

all_structs.append(PerfDatabase)
PerfDatabase.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'thisNodeName', True, None, 2, ), # 1
  (2, TType.LIST, 'eventInfo', (TType.STRUCT,[openr.Lsdb.ttypes.PerfEvents, openr.Lsdb.ttypes.PerfEvents.thrift_spec, False]), None, 2, ), # 2
)

PerfDatabase.thrift_struct_annotations = {
}
PerfDatabase.thrift_field_annotations = {
}

def PerfDatabase__init__(self, thisNodeName=None, eventInfo=None,):
  self.thisNodeName = thisNodeName
  self.eventInfo = eventInfo

PerfDatabase.__init__ = PerfDatabase__init__

all_structs.append(FibRequest)
FibRequest.thrift_spec = (
  None, # 0
  (1, TType.I32, 'cmd', FibCommand, None, 2, ), # 1
)

FibRequest.thrift_struct_annotations = {
}
FibRequest.thrift_field_annotations = {
}

def FibRequest__init__(self, cmd=None,):
  self.cmd = cmd

FibRequest.__init__ = FibRequest__init__

fix_spec(all_structs)
del all_structs
