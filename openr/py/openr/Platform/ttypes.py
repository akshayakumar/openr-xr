#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import six
from thrift.util.Recursive import fix_spec
from thrift.Thrift import *
from thrift.protocol.TProtocol import TProtocolException


import openr.IpPrefix.ttypes


import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
try:
  from thrift.protocol import fastproto
except:
  fastproto = None
all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'FibClient', 'PlatformEventType', 'LinkEntry', 'AddrEntry', 'NeighborEntry', 'Link', 'PlatformEvent', 'PlatformError']

class FibClient:
  """
  Enum to keep track of Client name to Client-ID mapping. Indicates which
  client-ids are used and which are available to use.
  """
  OPENR = 786
  CLIENT_1 = 1
  CLIENT_2 = 2
  CLIENT_3 = 3
  CLIENT_4 = 4
  CLIENT_5 = 5

  _VALUES_TO_NAMES = {
    786: "OPENR",
    1: "CLIENT_1",
    2: "CLIENT_2",
    3: "CLIENT_3",
    4: "CLIENT_4",
    5: "CLIENT_5",
  }

  _NAMES_TO_VALUES = {
    "OPENR": 786,
    "CLIENT_1": 1,
    "CLIENT_2": 2,
    "CLIENT_3": 3,
    "CLIENT_4": 4,
    "CLIENT_5": 5,
  }

class PlatformEventType:
  """
  Message sent over to subscriber of Platform Event.
  eventType to indicate type of netlink event to be updated
  eventData to indicate exact object entry to be updated
  Notice: when sending out PlatformEvent make sure to send multi part messages:
  part1: header to indicate event type,
  which is 2 byte of PlatformEventType cast to unsigned int
  part2: real message
  """
  LINK_EVENT = 1
  ADDRESS_EVENT = 2
  NEIGHBOR_EVENT = 3

  _VALUES_TO_NAMES = {
    1: "LINK_EVENT",
    2: "ADDRESS_EVENT",
    3: "NEIGHBOR_EVENT",
  }

  _NAMES_TO_VALUES = {
    "LINK_EVENT": 1,
    "ADDRESS_EVENT": 2,
    "NEIGHBOR_EVENT": 3,
  }

class LinkEntry:
  """
  We provide simple API to publish link/address/neighbor updating events
  through PUB-SUB mechanism to all of its subscriber modules in OpenR
  
  Attributes:
   - ifName
   - ifIndex
   - isUp
   - weight
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ifName = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.ifIndex = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.isUp = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.weight = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('LinkEntry')
    if self.ifName != None:
      oprot.writeFieldBegin('ifName', TType.STRING, 1)
      oprot.writeString(self.ifName.encode('utf-8')) if UTF8STRINGS and not isinstance(self.ifName, bytes) else oprot.writeString(self.ifName)
      oprot.writeFieldEnd()
    if self.ifIndex != None:
      oprot.writeFieldBegin('ifIndex', TType.I64, 2)
      oprot.writeI64(self.ifIndex)
      oprot.writeFieldEnd()
    if self.isUp != None:
      oprot.writeFieldBegin('isUp', TType.BOOL, 3)
      oprot.writeBool(self.isUp)
      oprot.writeFieldEnd()
    if self.weight != None:
      oprot.writeFieldBegin('weight', TType.I64, 4)
      oprot.writeI64(self.weight)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.ifName, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    ifName=%s' % (value))
    value = pprint.pformat(self.ifIndex, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    ifIndex=%s' % (value))
    value = pprint.pformat(self.isUp, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    isUp=%s' % (value))
    value = pprint.pformat(self.weight, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    weight=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class AddrEntry:
  """
  Attributes:
   - ifName
   - ipPrefix
   - isValid
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ifName = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.ipPrefix = openr.IpPrefix.ttypes.IpPrefix()
          self.ipPrefix.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.isValid = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AddrEntry')
    if self.ifName != None:
      oprot.writeFieldBegin('ifName', TType.STRING, 1)
      oprot.writeString(self.ifName.encode('utf-8')) if UTF8STRINGS and not isinstance(self.ifName, bytes) else oprot.writeString(self.ifName)
      oprot.writeFieldEnd()
    if self.ipPrefix != None:
      oprot.writeFieldBegin('ipPrefix', TType.STRUCT, 2)
      self.ipPrefix.write(oprot)
      oprot.writeFieldEnd()
    if self.isValid != None:
      oprot.writeFieldBegin('isValid', TType.BOOL, 3)
      oprot.writeBool(self.isValid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.ifName, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    ifName=%s' % (value))
    value = pprint.pformat(self.ipPrefix, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    ipPrefix=%s' % (value))
    value = pprint.pformat(self.isValid, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    isValid=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class NeighborEntry:
  """
  Attributes:
   - ifName
   - destination
   - linkAddr
   - isReachable
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ifName = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.destination = openr.IpPrefix.ttypes.BinaryAddress()
          self.destination.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.linkAddr = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BOOL:
          self.isReachable = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('NeighborEntry')
    if self.ifName != None:
      oprot.writeFieldBegin('ifName', TType.STRING, 1)
      oprot.writeString(self.ifName.encode('utf-8')) if UTF8STRINGS and not isinstance(self.ifName, bytes) else oprot.writeString(self.ifName)
      oprot.writeFieldEnd()
    if self.destination != None:
      oprot.writeFieldBegin('destination', TType.STRUCT, 2)
      self.destination.write(oprot)
      oprot.writeFieldEnd()
    if self.linkAddr != None:
      oprot.writeFieldBegin('linkAddr', TType.STRING, 3)
      oprot.writeString(self.linkAddr.encode('utf-8')) if UTF8STRINGS and not isinstance(self.linkAddr, bytes) else oprot.writeString(self.linkAddr)
      oprot.writeFieldEnd()
    if self.isReachable != None:
      oprot.writeFieldBegin('isReachable', TType.BOOL, 4)
      oprot.writeBool(self.isReachable)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.ifName, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    ifName=%s' % (value))
    value = pprint.pformat(self.destination, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    destination=%s' % (value))
    value = pprint.pformat(self.linkAddr, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    linkAddr=%s' % (value))
    value = pprint.pformat(self.isReachable, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    isReachable=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class Link:
  """
  Attributes:
   - ifIndex
   - isUp
   - networks
   - ifName
   - weight
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.ifIndex = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.isUp = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.networks = []
          (_etype3, _size0) = iprot.readListBegin()
          if _size0 >= 0:
            for _i4 in six.moves.range(_size0):
              _elem5 = openr.IpPrefix.ttypes.IpPrefix()
              _elem5.read(iprot)
              self.networks.append(_elem5)
          else: 
            while iprot.peekList():
              _elem6 = openr.IpPrefix.ttypes.IpPrefix()
              _elem6.read(iprot)
              self.networks.append(_elem6)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.ifName = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.weight = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Link')
    if self.ifIndex != None:
      oprot.writeFieldBegin('ifIndex', TType.I64, 1)
      oprot.writeI64(self.ifIndex)
      oprot.writeFieldEnd()
    if self.isUp != None:
      oprot.writeFieldBegin('isUp', TType.BOOL, 2)
      oprot.writeBool(self.isUp)
      oprot.writeFieldEnd()
    if self.networks != None:
      oprot.writeFieldBegin('networks', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.networks))
      for iter7 in self.networks:
        iter7.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.ifName != None:
      oprot.writeFieldBegin('ifName', TType.STRING, 4)
      oprot.writeString(self.ifName.encode('utf-8')) if UTF8STRINGS and not isinstance(self.ifName, bytes) else oprot.writeString(self.ifName)
      oprot.writeFieldEnd()
    if self.weight != None:
      oprot.writeFieldBegin('weight', TType.I64, 5)
      oprot.writeI64(self.weight)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.ifIndex, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    ifIndex=%s' % (value))
    value = pprint.pformat(self.isUp, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    isUp=%s' % (value))
    value = pprint.pformat(self.networks, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    networks=%s' % (value))
    value = pprint.pformat(self.ifName, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    ifName=%s' % (value))
    value = pprint.pformat(self.weight, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    weight=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class PlatformEvent:
  """
  Attributes:
   - eventType
   - eventData
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.eventType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.eventData = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('PlatformEvent')
    if self.eventType != None:
      oprot.writeFieldBegin('eventType', TType.I32, 1)
      oprot.writeI32(self.eventType)
      oprot.writeFieldEnd()
    if self.eventData != None:
      oprot.writeFieldBegin('eventData', TType.STRING, 2)
      oprot.writeString(self.eventData)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.eventType, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    eventType=%s' % (value))
    value = pprint.pformat(self.eventData, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    eventData=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class PlatformError(TException):
  """
  Attributes:
   - message
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('PlatformError')
    if self.message != None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message.encode('utf-8')) if UTF8STRINGS and not isinstance(self.message, bytes) else oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __str__(self):
    return repr(self)

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.message, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    message=%s' % (value))
    if 'message' not in self.__dict__:
      message = getattr(self, 'message', None)
      if message:
        L.append('message=%r' % message)
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(LinkEntry)
LinkEntry.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'ifName', True, None, 2, ), # 1
  (2, TType.I64, 'ifIndex', None, None, 2, ), # 2
  (3, TType.BOOL, 'isUp', None, None, 2, ), # 3
  (4, TType.I64, 'weight', None, 1, 2, ), # 4
)

LinkEntry.thrift_struct_annotations = {
}
LinkEntry.thrift_field_annotations = {
}

def LinkEntry__init__(self, ifName=None, ifIndex=None, isUp=None, weight=LinkEntry.thrift_spec[4][4],):
  self.ifName = ifName
  self.ifIndex = ifIndex
  self.isUp = isUp
  self.weight = weight

LinkEntry.__init__ = LinkEntry__init__

all_structs.append(AddrEntry)
AddrEntry.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'ifName', True, None, 2, ), # 1
  (2, TType.STRUCT, 'ipPrefix', [openr.IpPrefix.ttypes.IpPrefix, openr.IpPrefix.ttypes.IpPrefix.thrift_spec, False], None, 2, ), # 2
  (3, TType.BOOL, 'isValid', None, None, 2, ), # 3
)

AddrEntry.thrift_struct_annotations = {
}
AddrEntry.thrift_field_annotations = {
}

def AddrEntry__init__(self, ifName=None, ipPrefix=None, isValid=None,):
  self.ifName = ifName
  self.ipPrefix = ipPrefix
  self.isValid = isValid

AddrEntry.__init__ = AddrEntry__init__

all_structs.append(NeighborEntry)
NeighborEntry.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'ifName', True, None, 2, ), # 1
  (2, TType.STRUCT, 'destination', [openr.IpPrefix.ttypes.BinaryAddress, openr.IpPrefix.ttypes.BinaryAddress.thrift_spec, False], None, 2, ), # 2
  (3, TType.STRING, 'linkAddr', True, None, 2, ), # 3
  (4, TType.BOOL, 'isReachable', None, None, 2, ), # 4
)

NeighborEntry.thrift_struct_annotations = {
}
NeighborEntry.thrift_field_annotations = {
}

def NeighborEntry__init__(self, ifName=None, destination=None, linkAddr=None, isReachable=None,):
  self.ifName = ifName
  self.destination = destination
  self.linkAddr = linkAddr
  self.isReachable = isReachable

NeighborEntry.__init__ = NeighborEntry__init__

all_structs.append(Link)
Link.thrift_spec = (
  None, # 0
  (1, TType.I64, 'ifIndex', None, None, 2, ), # 1
  (2, TType.BOOL, 'isUp', None, None, 2, ), # 2
  (3, TType.LIST, 'networks', (TType.STRUCT,[openr.IpPrefix.ttypes.IpPrefix, openr.IpPrefix.ttypes.IpPrefix.thrift_spec, False]), None, 2, ), # 3
  (4, TType.STRING, 'ifName', True, None, 2, ), # 4
  (5, TType.I64, 'weight', None, 1, 2, ), # 5
)

Link.thrift_struct_annotations = {
}
Link.thrift_field_annotations = {
}

def Link__init__(self, ifIndex=None, isUp=None, networks=None, ifName=None, weight=Link.thrift_spec[5][4],):
  self.ifIndex = ifIndex
  self.isUp = isUp
  self.networks = networks
  self.ifName = ifName
  self.weight = weight

Link.__init__ = Link__init__

all_structs.append(PlatformEvent)
PlatformEvent.thrift_spec = (
  None, # 0
  (1, TType.I32, 'eventType', PlatformEventType, None, 2, ), # 1
  (2, TType.STRING, 'eventData', False, None, 2, ), # 2
)

PlatformEvent.thrift_struct_annotations = {
}
PlatformEvent.thrift_field_annotations = {
}

def PlatformEvent__init__(self, eventType=None, eventData=None,):
  self.eventType = eventType
  self.eventData = eventData

PlatformEvent.__init__ = PlatformEvent__init__

all_structs.append(PlatformError)
PlatformError.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'message', True, None, 2, ), # 1
)

PlatformError.thrift_struct_annotations = {
  "message": """message""",
}
PlatformError.thrift_field_annotations = {
}

def PlatformError__init__(self, message=None,):
  self.message = message

PlatformError.__init__ = PlatformError__init__

fix_spec(all_structs)
del all_structs
