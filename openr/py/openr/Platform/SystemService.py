#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import six
from thrift.util.Recursive import fix_spec
from thrift.Thrift import *
from thrift.protocol.TProtocol import TProtocolException


from .ttypes import *
import openr.IpPrefix.ttypes

from thrift.Thrift import TProcessor
import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
try:
  from thrift.protocol import fastproto
except:
  fastproto = None

all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

from thrift.util.Decorators import *

class Iface:
  """
  Thrift Service API definitions for on-box system information like links,
  addresses and neighbors. OpenR leverages links and address information as
  a part of link discovery and uses it to perform neighbor discovery on
  retrieved links. There is also PUB/SUB mechanism over which updates can be
  relayed to OpenR in realtime.
  """
  def getAllLinks(self, ):
    """
    SystemService client can query the following items:
    1. query all links keyed by interface names
    2. query all reachable neighbors
    """
    pass

  def getAllNeighbors(self, ):
    pass

  def addNlNeighbor(self, ifName=None, destAddr=None):
    """
    Parameters:
     - ifName
     - destAddr
    """
    pass

  def delNlNeighbor(self, ifName=None, destAddr=None):
    """
    Parameters:
     - ifName
     - destAddr
    """
    pass


class ContextIface:
  """
  Thrift Service API definitions for on-box system information like links,
  addresses and neighbors. OpenR leverages links and address information as
  a part of link discovery and uses it to perform neighbor discovery on
  retrieved links. There is also PUB/SUB mechanism over which updates can be
  relayed to OpenR in realtime.
  """
  def getAllLinks(self, handler_ctx, ):
    """
    SystemService client can query the following items:
    1. query all links keyed by interface names
    2. query all reachable neighbors
    """
    pass

  def getAllNeighbors(self, handler_ctx, ):
    pass

  def addNlNeighbor(self, handler_ctx, ifName=None, destAddr=None):
    """
    Parameters:
     - ifName
     - destAddr
    """
    pass

  def delNlNeighbor(self, handler_ctx, ifName=None, destAddr=None):
    """
    Parameters:
     - ifName
     - destAddr
    """
    pass


# HELPER FUNCTIONS AND STRUCTURES

class getAllLinks_args:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('getAllLinks_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(getAllLinks_args)
getAllLinks_args.thrift_spec = (
)

getAllLinks_args.thrift_struct_annotations = {
}
getAllLinks_args.thrift_field_annotations = {
}

class getAllLinks_result:
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype11, _size8) = iprot.readListBegin()
          if _size8 >= 0:
            for _i12 in six.moves.range(_size8):
              _elem13 = Link()
              _elem13.read(iprot)
              self.success.append(_elem13)
          else: 
            while iprot.peekList():
              _elem14 = Link()
              _elem14.read(iprot)
              self.success.append(_elem14)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = PlatformError()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('getAllLinks_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter15 in self.success:
        iter15.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.error != None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.success, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    success=%s' % (value))
    value = pprint.pformat(self.error, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    error=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(getAllLinks_result)
getAllLinks_result.thrift_spec = (
  (0, TType.LIST, 'success', (TType.STRUCT,[Link, Link.thrift_spec, False]), None, 2, ), # 0
  (1, TType.STRUCT, 'error', [PlatformError, PlatformError.thrift_spec, False], None, 2, ), # 1
)

getAllLinks_result.thrift_struct_annotations = {
}
getAllLinks_result.thrift_field_annotations = {
}

def getAllLinks_result__init__(self, success=None, error=None,):
  self.success = success
  self.error = error

getAllLinks_result.__init__ = getAllLinks_result__init__

class getAllNeighbors_args:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('getAllNeighbors_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(getAllNeighbors_args)
getAllNeighbors_args.thrift_spec = (
)

getAllNeighbors_args.thrift_struct_annotations = {
}
getAllNeighbors_args.thrift_field_annotations = {
}

class getAllNeighbors_result:
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype19, _size16) = iprot.readListBegin()
          if _size16 >= 0:
            for _i20 in six.moves.range(_size16):
              _elem21 = NeighborEntry()
              _elem21.read(iprot)
              self.success.append(_elem21)
          else: 
            while iprot.peekList():
              _elem22 = NeighborEntry()
              _elem22.read(iprot)
              self.success.append(_elem22)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = PlatformError()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('getAllNeighbors_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter23 in self.success:
        iter23.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.error != None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.success, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    success=%s' % (value))
    value = pprint.pformat(self.error, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    error=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(getAllNeighbors_result)
getAllNeighbors_result.thrift_spec = (
  (0, TType.LIST, 'success', (TType.STRUCT,[NeighborEntry, NeighborEntry.thrift_spec, False]), None, 2, ), # 0
  (1, TType.STRUCT, 'error', [PlatformError, PlatformError.thrift_spec, False], None, 2, ), # 1
)

getAllNeighbors_result.thrift_struct_annotations = {
}
getAllNeighbors_result.thrift_field_annotations = {
}

def getAllNeighbors_result__init__(self, success=None, error=None,):
  self.success = success
  self.error = error

getAllNeighbors_result.__init__ = getAllNeighbors_result__init__

class addNlNeighbor_args:
  """
  Attributes:
   - ifName
   - destAddr
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ifName = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.destAddr = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('addNlNeighbor_args')
    if self.ifName != None:
      oprot.writeFieldBegin('ifName', TType.STRING, 1)
      oprot.writeString(self.ifName.encode('utf-8')) if UTF8STRINGS and not isinstance(self.ifName, bytes) else oprot.writeString(self.ifName)
      oprot.writeFieldEnd()
    if self.destAddr != None:
      oprot.writeFieldBegin('destAddr', TType.STRING, 2)
      oprot.writeString(self.destAddr.encode('utf-8')) if UTF8STRINGS and not isinstance(self.destAddr, bytes) else oprot.writeString(self.destAddr)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.ifName, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    ifName=%s' % (value))
    value = pprint.pformat(self.destAddr, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    destAddr=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(addNlNeighbor_args)
addNlNeighbor_args.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'ifName', True, None, 2, ), # 1
  (2, TType.STRING, 'destAddr', True, None, 2, ), # 2
)

addNlNeighbor_args.thrift_struct_annotations = {
}
addNlNeighbor_args.thrift_field_annotations = {
}

def addNlNeighbor_args__init__(self, ifName=None, destAddr=None,):
  self.ifName = ifName
  self.destAddr = destAddr

addNlNeighbor_args.__init__ = addNlNeighbor_args__init__

class addNlNeighbor_result:
  """
  Attributes:
   - error
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.error = PlatformError()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('addNlNeighbor_result')
    if self.error != None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.error, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    error=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(addNlNeighbor_result)
addNlNeighbor_result.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'error', [PlatformError, PlatformError.thrift_spec, False], None, 2, ), # 1
)

addNlNeighbor_result.thrift_struct_annotations = {
}
addNlNeighbor_result.thrift_field_annotations = {
}

def addNlNeighbor_result__init__(self, error=None,):
  self.error = error

addNlNeighbor_result.__init__ = addNlNeighbor_result__init__

class delNlNeighbor_args:
  """
  Attributes:
   - ifName
   - destAddr
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.ifName = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.destAddr = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('delNlNeighbor_args')
    if self.ifName != None:
      oprot.writeFieldBegin('ifName', TType.STRING, 1)
      oprot.writeString(self.ifName.encode('utf-8')) if UTF8STRINGS and not isinstance(self.ifName, bytes) else oprot.writeString(self.ifName)
      oprot.writeFieldEnd()
    if self.destAddr != None:
      oprot.writeFieldBegin('destAddr', TType.STRING, 2)
      oprot.writeString(self.destAddr.encode('utf-8')) if UTF8STRINGS and not isinstance(self.destAddr, bytes) else oprot.writeString(self.destAddr)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.ifName, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    ifName=%s' % (value))
    value = pprint.pformat(self.destAddr, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    destAddr=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(delNlNeighbor_args)
delNlNeighbor_args.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'ifName', True, None, 2, ), # 1
  (2, TType.STRING, 'destAddr', True, None, 2, ), # 2
)

delNlNeighbor_args.thrift_struct_annotations = {
}
delNlNeighbor_args.thrift_field_annotations = {
}

def delNlNeighbor_args__init__(self, ifName=None, destAddr=None,):
  self.ifName = ifName
  self.destAddr = destAddr

delNlNeighbor_args.__init__ = delNlNeighbor_args__init__

class delNlNeighbor_result:
  """
  Attributes:
   - error
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.error = PlatformError()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('delNlNeighbor_result')
    if self.error != None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.error, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    error=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(delNlNeighbor_result)
delNlNeighbor_result.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'error', [PlatformError, PlatformError.thrift_spec, False], None, 2, ), # 1
)

delNlNeighbor_result.thrift_struct_annotations = {
}
delNlNeighbor_result.thrift_field_annotations = {
}

def delNlNeighbor_result__init__(self, error=None,):
  self.error = error

delNlNeighbor_result.__init__ = delNlNeighbor_result__init__

class Client(Iface):
  """
  Thrift Service API definitions for on-box system information like links,
  addresses and neighbors. OpenR leverages links and address information as
  a part of link discovery and uses it to perform neighbor discovery on
  retrieved links. There is also PUB/SUB mechanism over which updates can be
  relayed to OpenR in realtime.
  """
  def __enter__(self):
    return self

  def __exit__(self, type, value, tb):
    self._iprot.trans.close()
    if self._iprot is not self._oprot:
      self._oprot.trans.close()

  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot != None:
      self._oprot = oprot
    self._seqid = 0

  def getAllLinks(self, ):
    """
    SystemService client can query the following items:
    1. query all links keyed by interface names
    2. query all reachable neighbors
    """
    self.send_getAllLinks()
    return self.recv_getAllLinks()

  def send_getAllLinks(self, ):
    self._oprot.writeMessageBegin('getAllLinks', TMessageType.CALL, self._seqid)
    args = getAllLinks_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getAllLinks(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getAllLinks_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.error != None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getAllLinks failed: unknown result");

  def getAllNeighbors(self, ):
    self.send_getAllNeighbors()
    return self.recv_getAllNeighbors()

  def send_getAllNeighbors(self, ):
    self._oprot.writeMessageBegin('getAllNeighbors', TMessageType.CALL, self._seqid)
    args = getAllNeighbors_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getAllNeighbors(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getAllNeighbors_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.error != None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getAllNeighbors failed: unknown result");

  def addNlNeighbor(self, ifName=None, destAddr=None):
    """
    Parameters:
     - ifName
     - destAddr
    """
    self.send_addNlNeighbor(ifName, destAddr)
    self.recv_addNlNeighbor()

  def send_addNlNeighbor(self, ifName=None, destAddr=None):
    self._oprot.writeMessageBegin('addNlNeighbor', TMessageType.CALL, self._seqid)
    args = addNlNeighbor_args()
    args.ifName = ifName
    args.destAddr = destAddr
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_addNlNeighbor(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = addNlNeighbor_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.error != None:
      raise result.error
    return

  def delNlNeighbor(self, ifName=None, destAddr=None):
    """
    Parameters:
     - ifName
     - destAddr
    """
    self.send_delNlNeighbor(ifName, destAddr)
    self.recv_delNlNeighbor()

  def send_delNlNeighbor(self, ifName=None, destAddr=None):
    self._oprot.writeMessageBegin('delNlNeighbor', TMessageType.CALL, self._seqid)
    args = delNlNeighbor_args()
    args.ifName = ifName
    args.destAddr = destAddr
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_delNlNeighbor(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = delNlNeighbor_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.error != None:
      raise result.error
    return


class Processor(Iface, TProcessor):
  _onewayMethods = ()

  def __init__(self, handler):
    TProcessor.__init__(self)
    self._handler = handler
    self._processMap = {}
    self._processMap["getAllLinks"] = Processor.process_getAllLinks
    self._processMap["getAllNeighbors"] = Processor.process_getAllNeighbors
    self._processMap["addNlNeighbor"] = Processor.process_addNlNeighbor
    self._processMap["delNlNeighbor"] = Processor.process_delNlNeighbor

  def onewayMethods(self):
    l = []
    l.extend(Processor._onewayMethods)
    return tuple(l)

  @process_main()
  def process(self,): pass

  @process_method(getAllLinks_args, oneway=False)
  def process_getAllLinks(self, args, handler_ctx):
    result = getAllLinks_result()
    try:
      result.success = self._handler.getAllLinks()
    except PlatformError as exc0:
      self._event_handler.handlerException(handler_ctx, 'getAllLinks', exc0)
      result.error = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'getAllLinks', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(getAllNeighbors_args, oneway=False)
  def process_getAllNeighbors(self, args, handler_ctx):
    result = getAllNeighbors_result()
    try:
      result.success = self._handler.getAllNeighbors()
    except PlatformError as exc0:
      self._event_handler.handlerException(handler_ctx, 'getAllNeighbors', exc0)
      result.error = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'getAllNeighbors', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(addNlNeighbor_args, oneway=False)
  def process_addNlNeighbor(self, args, handler_ctx):
    result = addNlNeighbor_result()
    try:
      self._handler.addNlNeighbor(args.ifName, args.destAddr)
    except PlatformError as exc0:
      self._event_handler.handlerException(handler_ctx, 'addNlNeighbor', exc0)
      result.error = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'addNlNeighbor', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(delNlNeighbor_args, oneway=False)
  def process_delNlNeighbor(self, args, handler_ctx):
    result = delNlNeighbor_result()
    try:
      self._handler.delNlNeighbor(args.ifName, args.destAddr)
    except PlatformError as exc0:
      self._event_handler.handlerException(handler_ctx, 'delNlNeighbor', exc0)
      result.error = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'delNlNeighbor', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

Iface._processor_type = Processor

class ContextProcessor(ContextIface, TProcessor):
  _onewayMethods = ()

  def __init__(self, handler):
    TProcessor.__init__(self)
    self._handler = handler
    self._processMap = {}
    self._processMap["getAllLinks"] = ContextProcessor.process_getAllLinks
    self._processMap["getAllNeighbors"] = ContextProcessor.process_getAllNeighbors
    self._processMap["addNlNeighbor"] = ContextProcessor.process_addNlNeighbor
    self._processMap["delNlNeighbor"] = ContextProcessor.process_delNlNeighbor

  def onewayMethods(self):
    l = []
    l.extend(ContextProcessor._onewayMethods)
    return tuple(l)

  @process_main()
  def process(self,): pass

  @process_method(getAllLinks_args, oneway=False)
  def process_getAllLinks(self, args, handler_ctx):
    result = getAllLinks_result()
    try:
      result.success = self._handler.getAllLinks(handler_ctx)
    except PlatformError as exc0:
      self._event_handler.handlerException(handler_ctx, 'getAllLinks', exc0)
      result.error = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'getAllLinks', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(getAllNeighbors_args, oneway=False)
  def process_getAllNeighbors(self, args, handler_ctx):
    result = getAllNeighbors_result()
    try:
      result.success = self._handler.getAllNeighbors(handler_ctx)
    except PlatformError as exc0:
      self._event_handler.handlerException(handler_ctx, 'getAllNeighbors', exc0)
      result.error = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'getAllNeighbors', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(addNlNeighbor_args, oneway=False)
  def process_addNlNeighbor(self, args, handler_ctx):
    result = addNlNeighbor_result()
    try:
      self._handler.addNlNeighbor(handler_ctx, args.ifName, args.destAddr)
    except PlatformError as exc0:
      self._event_handler.handlerException(handler_ctx, 'addNlNeighbor', exc0)
      result.error = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'addNlNeighbor', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(delNlNeighbor_args, oneway=False)
  def process_delNlNeighbor(self, args, handler_ctx):
    result = delNlNeighbor_result()
    try:
      self._handler.delNlNeighbor(handler_ctx, args.ifName, args.destAddr)
    except PlatformError as exc0:
      self._event_handler.handlerException(handler_ctx, 'delNlNeighbor', exc0)
      result.error = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'delNlNeighbor', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

ContextIface._processor_type = ContextProcessor

fix_spec(all_structs)
del all_structs

