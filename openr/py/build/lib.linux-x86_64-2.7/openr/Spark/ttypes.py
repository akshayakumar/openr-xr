#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import six
from thrift.util.Recursive import fix_spec
from thrift.Thrift import *
from thrift.protocol.TProtocol import TProtocolException


import openr.IpPrefix.ttypes


import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
try:
  from thrift.protocol import fastproto
except:
  fastproto = None
all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'SparkNeighborEventType', 'SparkNeighbor', 'ReflectedNeighborInfo', 'SparkPayload', 'SparkHelloPacket', 'SparkNeighborEvent', 'SparkIfDbUpdateResult']

class SparkNeighborEventType:
  NEIGHBOR_UP = 1
  NEIGHBOR_DOWN = 2
  NEIGHBOR_RESTART = 3
  NEIGHBOR_RTT_CHANGE = 4

  _VALUES_TO_NAMES = {
    1: "NEIGHBOR_UP",
    2: "NEIGHBOR_DOWN",
    3: "NEIGHBOR_RESTART",
    4: "NEIGHBOR_RTT_CHANGE",
  }

  _NAMES_TO_VALUES = {
    "NEIGHBOR_UP": 1,
    "NEIGHBOR_DOWN": 2,
    "NEIGHBOR_RESTART": 3,
    "NEIGHBOR_RTT_CHANGE": 4,
  }

class SparkNeighbor:
  """
  Attributes:
   - domainName
   - nodeName
   - holdTime
   - publicKey
   - transportAddressV6
   - transportAddressV4
   - kvStorePubPort
   - kvStoreCmdPort
   - ifName
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 6:
        if ftype == TType.STRING:
          self.domainName = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRING:
          self.nodeName = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.holdTime = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.publicKey = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.transportAddressV6 = openr.IpPrefix.ttypes.BinaryAddress()
          self.transportAddressV6.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.transportAddressV4 = openr.IpPrefix.ttypes.BinaryAddress()
          self.transportAddressV4.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.kvStorePubPort = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.kvStoreCmdPort = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.ifName = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.domainName == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'domainName' was not found in serialized data! Struct: SparkNeighbor")

    if self.nodeName == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'nodeName' was not found in serialized data! Struct: SparkNeighbor")

    if self.holdTime == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'holdTime' was not found in serialized data! Struct: SparkNeighbor")

    if self.publicKey == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'publicKey' was not found in serialized data! Struct: SparkNeighbor")

    if self.kvStorePubPort == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'kvStorePubPort' was not found in serialized data! Struct: SparkNeighbor")

    if self.kvStoreCmdPort == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'kvStoreCmdPort' was not found in serialized data! Struct: SparkNeighbor")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('SparkNeighbor')
    if self.nodeName != None:
      oprot.writeFieldBegin('nodeName', TType.STRING, 1)
      oprot.writeString(self.nodeName.encode('utf-8')) if UTF8STRINGS and not isinstance(self.nodeName, bytes) else oprot.writeString(self.nodeName)
      oprot.writeFieldEnd()
    if self.holdTime != None:
      oprot.writeFieldBegin('holdTime', TType.I32, 2)
      oprot.writeI32(self.holdTime)
      oprot.writeFieldEnd()
    if self.publicKey != None:
      oprot.writeFieldBegin('publicKey', TType.STRING, 3)
      oprot.writeString(self.publicKey)
      oprot.writeFieldEnd()
    if self.transportAddressV6 != None:
      oprot.writeFieldBegin('transportAddressV6', TType.STRUCT, 4)
      self.transportAddressV6.write(oprot)
      oprot.writeFieldEnd()
    if self.transportAddressV4 != None:
      oprot.writeFieldBegin('transportAddressV4', TType.STRUCT, 5)
      self.transportAddressV4.write(oprot)
      oprot.writeFieldEnd()
    if self.domainName != None:
      oprot.writeFieldBegin('domainName', TType.STRING, 6)
      oprot.writeString(self.domainName.encode('utf-8')) if UTF8STRINGS and not isinstance(self.domainName, bytes) else oprot.writeString(self.domainName)
      oprot.writeFieldEnd()
    if self.kvStorePubPort != None:
      oprot.writeFieldBegin('kvStorePubPort', TType.I32, 7)
      oprot.writeI32(self.kvStorePubPort)
      oprot.writeFieldEnd()
    if self.kvStoreCmdPort != None:
      oprot.writeFieldBegin('kvStoreCmdPort', TType.I32, 8)
      oprot.writeI32(self.kvStoreCmdPort)
      oprot.writeFieldEnd()
    if self.ifName != None:
      oprot.writeFieldBegin('ifName', TType.STRING, 9)
      oprot.writeString(self.ifName.encode('utf-8')) if UTF8STRINGS and not isinstance(self.ifName, bytes) else oprot.writeString(self.ifName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.domainName, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    domainName=%s' % (value))
    value = pprint.pformat(self.nodeName, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    nodeName=%s' % (value))
    value = pprint.pformat(self.holdTime, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    holdTime=%s' % (value))
    value = pprint.pformat(self.publicKey, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    publicKey=%s' % (value))
    value = pprint.pformat(self.transportAddressV6, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    transportAddressV6=%s' % (value))
    value = pprint.pformat(self.transportAddressV4, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    transportAddressV4=%s' % (value))
    value = pprint.pformat(self.kvStorePubPort, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    kvStorePubPort=%s' % (value))
    value = pprint.pformat(self.kvStoreCmdPort, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    kvStoreCmdPort=%s' % (value))
    value = pprint.pformat(self.ifName, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    ifName=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class ReflectedNeighborInfo:
  """
  Attributes:
   - seqNum
   - lastNbrMsgSentTsInUs
   - lastMyMsgRcvdTsInUs
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.seqNum = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.lastNbrMsgSentTsInUs = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.lastMyMsgRcvdTsInUs = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('ReflectedNeighborInfo')
    if self.seqNum != None:
      oprot.writeFieldBegin('seqNum', TType.I64, 1)
      oprot.writeI64(self.seqNum)
      oprot.writeFieldEnd()
    if self.lastNbrMsgSentTsInUs != None:
      oprot.writeFieldBegin('lastNbrMsgSentTsInUs', TType.I64, 2)
      oprot.writeI64(self.lastNbrMsgSentTsInUs)
      oprot.writeFieldEnd()
    if self.lastMyMsgRcvdTsInUs != None:
      oprot.writeFieldBegin('lastMyMsgRcvdTsInUs', TType.I64, 3)
      oprot.writeI64(self.lastMyMsgRcvdTsInUs)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.seqNum, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    seqNum=%s' % (value))
    value = pprint.pformat(self.lastNbrMsgSentTsInUs, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    lastNbrMsgSentTsInUs=%s' % (value))
    value = pprint.pformat(self.lastMyMsgRcvdTsInUs, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    lastMyMsgRcvdTsInUs=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class SparkPayload:
  """
  Attributes:
   - originator
   - seqNum
   - neighborInfos
   - timestamp
   - solicitResponse
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.originator = SparkNeighbor()
          self.originator.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.seqNum = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.neighborInfos = {}
          (_ktype1, _vtype2, _size0 ) = iprot.readMapBegin() 
          if _size0 >= 0:
            for _i4 in six.moves.range(_size0):
              _key5 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val6 = ReflectedNeighborInfo()
              _val6.read(iprot)
              self.neighborInfos[_key5] = _val6
          else: 
            while iprot.peekMap():
              _key7 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val8 = ReflectedNeighborInfo()
              _val8.read(iprot)
              self.neighborInfos[_key7] = _val8
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.solicitResponse = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.originator == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'originator' was not found in serialized data! Struct: SparkPayload")

    if self.seqNum == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'seqNum' was not found in serialized data! Struct: SparkPayload")

    if self.neighborInfos == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'neighborInfos' was not found in serialized data! Struct: SparkPayload")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('SparkPayload')
    if self.originator != None:
      oprot.writeFieldBegin('originator', TType.STRUCT, 1)
      self.originator.write(oprot)
      oprot.writeFieldEnd()
    if self.seqNum != None:
      oprot.writeFieldBegin('seqNum', TType.I64, 3)
      oprot.writeI64(self.seqNum)
      oprot.writeFieldEnd()
    if self.neighborInfos != None:
      oprot.writeFieldBegin('neighborInfos', TType.MAP, 4)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.neighborInfos))
      for kiter9,viter10 in self.neighborInfos.items():
        oprot.writeString(kiter9.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter9, bytes) else oprot.writeString(kiter9)
        viter10.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.timestamp != None:
      oprot.writeFieldBegin('timestamp', TType.I64, 5)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.solicitResponse != None:
      oprot.writeFieldBegin('solicitResponse', TType.BOOL, 6)
      oprot.writeBool(self.solicitResponse)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.originator, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    originator=%s' % (value))
    value = pprint.pformat(self.seqNum, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    seqNum=%s' % (value))
    value = pprint.pformat(self.neighborInfos, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    neighborInfos=%s' % (value))
    value = pprint.pformat(self.timestamp, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    timestamp=%s' % (value))
    value = pprint.pformat(self.solicitResponse, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    solicitResponse=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class SparkHelloPacket:
  """
  Attributes:
   - payload
   - signature
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.payload = SparkPayload()
          self.payload.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.signature = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.payload == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'payload' was not found in serialized data! Struct: SparkHelloPacket")

    if self.signature == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'signature' was not found in serialized data! Struct: SparkHelloPacket")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('SparkHelloPacket')
    if self.payload != None:
      oprot.writeFieldBegin('payload', TType.STRUCT, 1)
      self.payload.write(oprot)
      oprot.writeFieldEnd()
    if self.signature != None:
      oprot.writeFieldBegin('signature', TType.STRING, 2)
      oprot.writeString(self.signature)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.payload, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    payload=%s' % (value))
    value = pprint.pformat(self.signature, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    signature=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class SparkNeighborEvent:
  """
  Attributes:
   - eventType
   - ifName
   - neighbor
   - rttUs
   - label
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.eventType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ifName = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.neighbor = SparkNeighbor()
          self.neighbor.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.rttUs = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.label = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.eventType == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'eventType' was not found in serialized data! Struct: SparkNeighborEvent")

    if self.ifName == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'ifName' was not found in serialized data! Struct: SparkNeighborEvent")

    if self.neighbor == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'neighbor' was not found in serialized data! Struct: SparkNeighborEvent")

    if self.rttUs == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'rttUs' was not found in serialized data! Struct: SparkNeighborEvent")

    if self.label == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'label' was not found in serialized data! Struct: SparkNeighborEvent")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('SparkNeighborEvent')
    if self.eventType != None:
      oprot.writeFieldBegin('eventType', TType.I32, 1)
      oprot.writeI32(self.eventType)
      oprot.writeFieldEnd()
    if self.ifName != None:
      oprot.writeFieldBegin('ifName', TType.STRING, 2)
      oprot.writeString(self.ifName.encode('utf-8')) if UTF8STRINGS and not isinstance(self.ifName, bytes) else oprot.writeString(self.ifName)
      oprot.writeFieldEnd()
    if self.neighbor != None:
      oprot.writeFieldBegin('neighbor', TType.STRUCT, 3)
      self.neighbor.write(oprot)
      oprot.writeFieldEnd()
    if self.rttUs != None:
      oprot.writeFieldBegin('rttUs', TType.I64, 4)
      oprot.writeI64(self.rttUs)
      oprot.writeFieldEnd()
    if self.label != None:
      oprot.writeFieldBegin('label', TType.I32, 5)
      oprot.writeI32(self.label)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.eventType, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    eventType=%s' % (value))
    value = pprint.pformat(self.ifName, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    ifName=%s' % (value))
    value = pprint.pformat(self.neighbor, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    neighbor=%s' % (value))
    value = pprint.pformat(self.rttUs, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    rttUs=%s' % (value))
    value = pprint.pformat(self.label, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    label=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class SparkIfDbUpdateResult:
  """
  Attributes:
   - isSuccess
   - errString
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.isSuccess = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.errString = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('SparkIfDbUpdateResult')
    if self.isSuccess != None:
      oprot.writeFieldBegin('isSuccess', TType.BOOL, 1)
      oprot.writeBool(self.isSuccess)
      oprot.writeFieldEnd()
    if self.errString != None:
      oprot.writeFieldBegin('errString', TType.STRING, 2)
      oprot.writeString(self.errString.encode('utf-8')) if UTF8STRINGS and not isinstance(self.errString, bytes) else oprot.writeString(self.errString)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.isSuccess, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    isSuccess=%s' % (value))
    value = pprint.pformat(self.errString, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    errString=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(SparkNeighbor)
SparkNeighbor.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'nodeName', True, None, 0, ), # 1
  (2, TType.I32, 'holdTime', None, None, 0, ), # 2
  (3, TType.STRING, 'publicKey', False, None, 0, ), # 3
  (4, TType.STRUCT, 'transportAddressV6', [openr.IpPrefix.ttypes.BinaryAddress, openr.IpPrefix.ttypes.BinaryAddress.thrift_spec, False], None, 2, ), # 4
  (5, TType.STRUCT, 'transportAddressV4', [openr.IpPrefix.ttypes.BinaryAddress, openr.IpPrefix.ttypes.BinaryAddress.thrift_spec, False], None, 2, ), # 5
  (6, TType.STRING, 'domainName', True, None, 0, ), # 6
  (7, TType.I32, 'kvStorePubPort', None, None, 0, ), # 7
  (8, TType.I32, 'kvStoreCmdPort', None, None, 0, ), # 8
  (9, TType.STRING, 'ifName', True, "", 2, ), # 9
)

SparkNeighbor.thrift_struct_annotations = {
}
SparkNeighbor.thrift_field_annotations = {
}

def SparkNeighbor__init__(self, domainName=None, nodeName=None, holdTime=None, publicKey=None, transportAddressV6=None, transportAddressV4=None, kvStorePubPort=None, kvStoreCmdPort=None, ifName=SparkNeighbor.thrift_spec[9][4],):
  self.domainName = domainName
  self.nodeName = nodeName
  self.holdTime = holdTime
  self.publicKey = publicKey
  self.transportAddressV6 = transportAddressV6
  self.transportAddressV4 = transportAddressV4
  self.kvStorePubPort = kvStorePubPort
  self.kvStoreCmdPort = kvStoreCmdPort
  self.ifName = ifName

SparkNeighbor.__init__ = SparkNeighbor__init__

all_structs.append(ReflectedNeighborInfo)
ReflectedNeighborInfo.thrift_spec = (
  None, # 0
  (1, TType.I64, 'seqNum', None, 0, 2, ), # 1
  (2, TType.I64, 'lastNbrMsgSentTsInUs', None, 0, 2, ), # 2
  (3, TType.I64, 'lastMyMsgRcvdTsInUs', None, 0, 2, ), # 3
)

ReflectedNeighborInfo.thrift_struct_annotations = {
}
ReflectedNeighborInfo.thrift_field_annotations = {
}

def ReflectedNeighborInfo__init__(self, seqNum=ReflectedNeighborInfo.thrift_spec[1][4], lastNbrMsgSentTsInUs=ReflectedNeighborInfo.thrift_spec[2][4], lastMyMsgRcvdTsInUs=ReflectedNeighborInfo.thrift_spec[3][4],):
  self.seqNum = seqNum
  self.lastNbrMsgSentTsInUs = lastNbrMsgSentTsInUs
  self.lastMyMsgRcvdTsInUs = lastMyMsgRcvdTsInUs

ReflectedNeighborInfo.__init__ = ReflectedNeighborInfo__init__

all_structs.append(SparkPayload)
SparkPayload.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'originator', [SparkNeighbor, SparkNeighbor.thrift_spec, False], None, 0, ), # 1
  None, # 2
  (3, TType.I64, 'seqNum', None, None, 0, ), # 3
  (4, TType.MAP, 'neighborInfos', (TType.STRING,True,TType.STRUCT,[ReflectedNeighborInfo, ReflectedNeighborInfo.thrift_spec, False]), None, 0, ), # 4
  (5, TType.I64, 'timestamp', None, None, 2, ), # 5
  (6, TType.BOOL, 'solicitResponse', None, False, 2, ), # 6
)

SparkPayload.thrift_struct_annotations = {
}
SparkPayload.thrift_field_annotations = {
}

def SparkPayload__init__(self, originator=None, seqNum=None, neighborInfos=None, timestamp=None, solicitResponse=SparkPayload.thrift_spec[6][4],):
  self.originator = originator
  self.seqNum = seqNum
  self.neighborInfos = neighborInfos
  self.timestamp = timestamp
  self.solicitResponse = solicitResponse

SparkPayload.__init__ = SparkPayload__init__

all_structs.append(SparkHelloPacket)
SparkHelloPacket.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'payload', [SparkPayload, SparkPayload.thrift_spec, False], None, 0, ), # 1
  (2, TType.STRING, 'signature', False, None, 0, ), # 2
)

SparkHelloPacket.thrift_struct_annotations = {
}
SparkHelloPacket.thrift_field_annotations = {
}

def SparkHelloPacket__init__(self, payload=None, signature=None,):
  self.payload = payload
  self.signature = signature

SparkHelloPacket.__init__ = SparkHelloPacket__init__

all_structs.append(SparkNeighborEvent)
SparkNeighborEvent.thrift_spec = (
  None, # 0
  (1, TType.I32, 'eventType', SparkNeighborEventType, None, 0, ), # 1
  (2, TType.STRING, 'ifName', True, None, 0, ), # 2
  (3, TType.STRUCT, 'neighbor', [SparkNeighbor, SparkNeighbor.thrift_spec, False], None, 0, ), # 3
  (4, TType.I64, 'rttUs', None, None, 0, ), # 4
  (5, TType.I32, 'label', None, None, 0, ), # 5
)

SparkNeighborEvent.thrift_struct_annotations = {
}
SparkNeighborEvent.thrift_field_annotations = {
}

def SparkNeighborEvent__init__(self, eventType=None, ifName=None, neighbor=None, rttUs=None, label=None,):
  self.eventType = eventType
  self.ifName = ifName
  self.neighbor = neighbor
  self.rttUs = rttUs
  self.label = label

SparkNeighborEvent.__init__ = SparkNeighborEvent__init__

all_structs.append(SparkIfDbUpdateResult)
SparkIfDbUpdateResult.thrift_spec = (
  None, # 0
  (1, TType.BOOL, 'isSuccess', None, None, 2, ), # 1
  (2, TType.STRING, 'errString', True, None, 2, ), # 2
)

SparkIfDbUpdateResult.thrift_struct_annotations = {
}
SparkIfDbUpdateResult.thrift_field_annotations = {
}

def SparkIfDbUpdateResult__init__(self, isSuccess=None, errString=None,):
  self.isSuccess = isSuccess
  self.errString = errString

SparkIfDbUpdateResult.__init__ = SparkIfDbUpdateResult__init__

fix_spec(all_structs)
del all_structs
