#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import six
from thrift.util.Recursive import fix_spec
from thrift.Thrift import *
from thrift.protocol.TProtocol import TProtocolException


import openr.Platform.FibService
from .ttypes import *
import openr.Platform.ttypes
import openr.IpPrefix.ttypes

from thrift.Thrift import TProcessor
import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
try:
  from thrift.protocol import fastproto
except:
  fastproto = None

all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

from thrift.util.Decorators import *

class Iface(openr.Platform.FibService.Iface):
  """
  Platform.fibService provides common functionality all Platforms must
  must implement.
  
  Here we extend the service here to provide Linux Fib specific functionality
  In this case it is to export the kernel routing table Other Fib agents can
  export things like Hardware state, stats, counters, etc.
  """
  def getKernelRouteTable(self, ):
    pass


class ContextIface(openr.Platform.FibService.ContextIface):
  """
  Platform.fibService provides common functionality all Platforms must
  must implement.
  
  Here we extend the service here to provide Linux Fib specific functionality
  In this case it is to export the kernel routing table Other Fib agents can
  export things like Hardware state, stats, counters, etc.
  """
  def getKernelRouteTable(self, handler_ctx, ):
    pass


# HELPER FUNCTIONS AND STRUCTURES

class getKernelRouteTable_args:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('getKernelRouteTable_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(getKernelRouteTable_args)
getKernelRouteTable_args.thrift_spec = (
)

getKernelRouteTable_args.thrift_struct_annotations = {
}
getKernelRouteTable_args.thrift_field_annotations = {
}

class getKernelRouteTable_result:
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype3, _size0) = iprot.readListBegin()
          if _size0 >= 0:
            for _i4 in six.moves.range(_size0):
              _elem5 = openr.IpPrefix.ttypes.UnicastRoute()
              _elem5.read(iprot)
              self.success.append(_elem5)
          else: 
            while iprot.peekList():
              _elem6 = openr.IpPrefix.ttypes.UnicastRoute()
              _elem6.read(iprot)
              self.success.append(_elem6)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = openr.Platform.ttypes.PlatformError()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('getKernelRouteTable_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter7 in self.success:
        iter7.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.error != None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.success, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    success=%s' % (value))
    value = pprint.pformat(self.error, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    error=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(getKernelRouteTable_result)
getKernelRouteTable_result.thrift_spec = (
  (0, TType.LIST, 'success', (TType.STRUCT,[openr.IpPrefix.ttypes.UnicastRoute, openr.IpPrefix.ttypes.UnicastRoute.thrift_spec, False]), None, 2, ), # 0
  (1, TType.STRUCT, 'error', [openr.Platform.ttypes.PlatformError, openr.Platform.ttypes.PlatformError.thrift_spec, False], None, 2, ), # 1
)

getKernelRouteTable_result.thrift_struct_annotations = {
}
getKernelRouteTable_result.thrift_field_annotations = {
}

def getKernelRouteTable_result__init__(self, success=None, error=None,):
  self.success = success
  self.error = error

getKernelRouteTable_result.__init__ = getKernelRouteTable_result__init__

class Client(openr.Platform.FibService.Client, Iface):
  """
  Platform.fibService provides common functionality all Platforms must
  must implement.
  
  Here we extend the service here to provide Linux Fib specific functionality
  In this case it is to export the kernel routing table Other Fib agents can
  export things like Hardware state, stats, counters, etc.
  """
  def __enter__(self):
    return self

  def __exit__(self, type, value, tb):
    self._iprot.trans.close()
    if self._iprot is not self._oprot:
      self._oprot.trans.close()

  def __init__(self, iprot, oprot=None):
    openr.Platform.FibService.Client.__init__(self, iprot, oprot)

  def getKernelRouteTable(self, ):
    self.send_getKernelRouteTable()
    return self.recv_getKernelRouteTable()

  def send_getKernelRouteTable(self, ):
    self._oprot.writeMessageBegin('getKernelRouteTable', TMessageType.CALL, self._seqid)
    args = getKernelRouteTable_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getKernelRouteTable(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getKernelRouteTable_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.error != None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getKernelRouteTable failed: unknown result");


class Processor(openr.Platform.FibService.Processor, Iface, TProcessor):
  _onewayMethods = ()

  def __init__(self, handler):
    openr.Platform.FibService.Processor.__init__(self, handler)
    self._processMap["getKernelRouteTable"] = Processor.process_getKernelRouteTable

  def onewayMethods(self):
    l = []
    l.extend(openr.Platform.FibService.Processor.onewayMethods(self))
    l.extend(Processor._onewayMethods)
    return tuple(l)

  @process_main()
  def process(self,): pass

  @process_method(getKernelRouteTable_args, oneway=False)
  def process_getKernelRouteTable(self, args, handler_ctx):
    result = getKernelRouteTable_result()
    try:
      result.success = self._handler.getKernelRouteTable()
    except openr.Platform.ttypes.PlatformError as exc0:
      self._event_handler.handlerException(handler_ctx, 'getKernelRouteTable', exc0)
      result.error = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'getKernelRouteTable', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

Iface._processor_type = Processor

class ContextProcessor(openr.Platform.FibService.ContextProcessor, ContextIface, TProcessor):
  _onewayMethods = ()

  def __init__(self, handler):
    openr.Platform.FibService.ContextProcessor.__init__(self, handler)
    self._processMap["getKernelRouteTable"] = ContextProcessor.process_getKernelRouteTable

  def onewayMethods(self):
    l = []
    l.extend(openr.Platform.FibService.ContextProcessor.onewayMethods(self))
    l.extend(ContextProcessor._onewayMethods)
    return tuple(l)

  @process_main()
  def process(self,): pass

  @process_method(getKernelRouteTable_args, oneway=False)
  def process_getKernelRouteTable(self, args, handler_ctx):
    result = getKernelRouteTable_result()
    try:
      result.success = self._handler.getKernelRouteTable(handler_ctx)
    except openr.Platform.ttypes.PlatformError as exc0:
      self._event_handler.handlerException(handler_ctx, 'getKernelRouteTable', exc0)
      result.error = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'getKernelRouteTable', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

ContextIface._processor_type = ContextProcessor

fix_spec(all_structs)
del all_structs

