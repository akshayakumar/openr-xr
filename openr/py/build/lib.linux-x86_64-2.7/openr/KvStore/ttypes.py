#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import six
from thrift.util.Recursive import fix_spec
from thrift.Thrift import *
from thrift.protocol.TProtocol import TProtocolException



import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
try:
  from thrift.protocol import fastproto
except:
  fastproto = None
all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'Command', 'Value', 'KeySetParams', 'KeyGetParams', 'KeyDumpParams', 'PeerSpec', 'PeerAddParams', 'PeerDelParams', 'Request', 'Publication', 'PeerCmdReply']

class Command:
  KEY_SET = 1
  KEY_GET = 2
  KEY_DUMP = 3
  HASH_DUMP = 7
  PEER_ADD = 4
  PEER_DEL = 5
  PEER_DUMP = 6

  _VALUES_TO_NAMES = {
    1: "KEY_SET",
    2: "KEY_GET",
    3: "KEY_DUMP",
    7: "HASH_DUMP",
    4: "PEER_ADD",
    5: "PEER_DEL",
    6: "PEER_DUMP",
  }

  _NAMES_TO_VALUES = {
    "KEY_SET": 1,
    "KEY_GET": 2,
    "KEY_DUMP": 3,
    "HASH_DUMP": 7,
    "PEER_ADD": 4,
    "PEER_DEL": 5,
    "PEER_DUMP": 6,
  }

class Value:
  """
  Attributes:
   - version
   - originatorId
   - value
   - ttl
   - ttlVersion
   - hash
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.version = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.originatorId = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.value = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.ttl = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I64:
          self.ttlVersion = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I64:
          self.hash = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Value')
    if self.version != None:
      oprot.writeFieldBegin('version', TType.I64, 1)
      oprot.writeI64(self.version)
      oprot.writeFieldEnd()
    if self.value != None:
      oprot.writeFieldBegin('value', TType.STRING, 2)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    if self.originatorId != None:
      oprot.writeFieldBegin('originatorId', TType.STRING, 3)
      oprot.writeString(self.originatorId.encode('utf-8')) if UTF8STRINGS and not isinstance(self.originatorId, bytes) else oprot.writeString(self.originatorId)
      oprot.writeFieldEnd()
    if self.ttl != None:
      oprot.writeFieldBegin('ttl', TType.I64, 4)
      oprot.writeI64(self.ttl)
      oprot.writeFieldEnd()
    if self.ttlVersion != None:
      oprot.writeFieldBegin('ttlVersion', TType.I64, 5)
      oprot.writeI64(self.ttlVersion)
      oprot.writeFieldEnd()
    if self.hash != None:
      oprot.writeFieldBegin('hash', TType.I64, 6)
      oprot.writeI64(self.hash)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.version, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    version=%s' % (value))
    value = pprint.pformat(self.originatorId, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    originatorId=%s' % (value))
    value = pprint.pformat(self.value, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    value=%s' % (value))
    value = pprint.pformat(self.ttl, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    ttl=%s' % (value))
    value = pprint.pformat(self.ttlVersion, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    ttlVersion=%s' % (value))
    value = pprint.pformat(self.hash, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    hash=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class KeySetParams:
  """
  Attributes:
   - keyVals
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.MAP:
          self.keyVals = {}
          (_ktype1, _vtype2, _size0 ) = iprot.readMapBegin() 
          if _size0 >= 0:
            for _i4 in six.moves.range(_size0):
              _key5 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val6 = Value()
              _val6.read(iprot)
              self.keyVals[_key5] = _val6
          else: 
            while iprot.peekMap():
              _key7 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val8 = Value()
              _val8.read(iprot)
              self.keyVals[_key7] = _val8
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('KeySetParams')
    if self.keyVals != None:
      oprot.writeFieldBegin('keyVals', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.keyVals))
      for kiter9,viter10 in self.keyVals.items():
        oprot.writeString(kiter9.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter9, bytes) else oprot.writeString(kiter9)
        viter10.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.keyVals, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    keyVals=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class KeyGetParams:
  """
  Attributes:
   - keys
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.keys = []
          (_etype14, _size11) = iprot.readListBegin()
          if _size11 >= 0:
            for _i15 in six.moves.range(_size11):
              _elem16 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.keys.append(_elem16)
          else: 
            while iprot.peekList():
              _elem17 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.keys.append(_elem17)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('KeyGetParams')
    if self.keys != None:
      oprot.writeFieldBegin('keys', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.keys))
      for iter18 in self.keys:
        oprot.writeString(iter18.encode('utf-8')) if UTF8STRINGS and not isinstance(iter18, bytes) else oprot.writeString(iter18)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.keys, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    keys=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class KeyDumpParams:
  """
  Attributes:
   - prefix
   - keyValHashes
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.prefix = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.keyValHashes = {}
          (_ktype20, _vtype21, _size19 ) = iprot.readMapBegin() 
          if _size19 >= 0:
            for _i23 in six.moves.range(_size19):
              _key24 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val25 = Value()
              _val25.read(iprot)
              self.keyValHashes[_key24] = _val25
          else: 
            while iprot.peekMap():
              _key26 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val27 = Value()
              _val27.read(iprot)
              self.keyValHashes[_key26] = _val27
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('KeyDumpParams')
    if self.prefix != None:
      oprot.writeFieldBegin('prefix', TType.STRING, 1)
      oprot.writeString(self.prefix.encode('utf-8')) if UTF8STRINGS and not isinstance(self.prefix, bytes) else oprot.writeString(self.prefix)
      oprot.writeFieldEnd()
    if self.keyValHashes != None:
      oprot.writeFieldBegin('keyValHashes', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.keyValHashes))
      for kiter28,viter29 in self.keyValHashes.items():
        oprot.writeString(kiter28.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter28, bytes) else oprot.writeString(kiter28)
        viter29.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.prefix, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    prefix=%s' % (value))
    value = pprint.pformat(self.keyValHashes, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    keyValHashes=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class PeerSpec:
  """
  Attributes:
   - pubUrl
   - cmdUrl
   - publicKey
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.pubUrl = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.cmdUrl = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.publicKey = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('PeerSpec')
    if self.pubUrl != None:
      oprot.writeFieldBegin('pubUrl', TType.STRING, 1)
      oprot.writeString(self.pubUrl.encode('utf-8')) if UTF8STRINGS and not isinstance(self.pubUrl, bytes) else oprot.writeString(self.pubUrl)
      oprot.writeFieldEnd()
    if self.cmdUrl != None:
      oprot.writeFieldBegin('cmdUrl', TType.STRING, 2)
      oprot.writeString(self.cmdUrl.encode('utf-8')) if UTF8STRINGS and not isinstance(self.cmdUrl, bytes) else oprot.writeString(self.cmdUrl)
      oprot.writeFieldEnd()
    if self.publicKey != None:
      oprot.writeFieldBegin('publicKey', TType.STRING, 3)
      oprot.writeString(self.publicKey)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.pubUrl, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    pubUrl=%s' % (value))
    value = pprint.pformat(self.cmdUrl, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    cmdUrl=%s' % (value))
    value = pprint.pformat(self.publicKey, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    publicKey=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class PeerAddParams:
  """
  Attributes:
   - peers
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.peers = {}
          (_ktype31, _vtype32, _size30 ) = iprot.readMapBegin() 
          if _size30 >= 0:
            for _i34 in six.moves.range(_size30):
              _key35 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val36 = PeerSpec()
              _val36.read(iprot)
              self.peers[_key35] = _val36
          else: 
            while iprot.peekMap():
              _key37 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val38 = PeerSpec()
              _val38.read(iprot)
              self.peers[_key37] = _val38
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('PeerAddParams')
    if self.peers != None:
      oprot.writeFieldBegin('peers', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.peers))
      for kiter39,viter40 in self.peers.items():
        oprot.writeString(kiter39.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter39, bytes) else oprot.writeString(kiter39)
        viter40.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.peers, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    peers=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class PeerDelParams:
  """
  Attributes:
   - peerNames
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.peerNames = []
          (_etype44, _size41) = iprot.readListBegin()
          if _size41 >= 0:
            for _i45 in six.moves.range(_size41):
              _elem46 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.peerNames.append(_elem46)
          else: 
            while iprot.peekList():
              _elem47 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.peerNames.append(_elem47)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('PeerDelParams')
    if self.peerNames != None:
      oprot.writeFieldBegin('peerNames', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.peerNames))
      for iter48 in self.peerNames:
        oprot.writeString(iter48.encode('utf-8')) if UTF8STRINGS and not isinstance(iter48, bytes) else oprot.writeString(iter48)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.peerNames, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    peerNames=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class Request:
  """
  Attributes:
   - cmd
   - keySetParams
   - keyGetParams
   - keyDumpParams
   - peerAddParams
   - peerDelParams
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.cmd = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.keySetParams = KeySetParams()
          self.keySetParams.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.keyGetParams = KeyGetParams()
          self.keyGetParams.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.keyDumpParams = KeyDumpParams()
          self.keyDumpParams.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.peerAddParams = PeerAddParams()
          self.peerAddParams.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.peerDelParams = PeerDelParams()
          self.peerDelParams.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Request')
    if self.cmd != None:
      oprot.writeFieldBegin('cmd', TType.I32, 1)
      oprot.writeI32(self.cmd)
      oprot.writeFieldEnd()
    if self.keySetParams != None:
      oprot.writeFieldBegin('keySetParams', TType.STRUCT, 2)
      self.keySetParams.write(oprot)
      oprot.writeFieldEnd()
    if self.keyGetParams != None:
      oprot.writeFieldBegin('keyGetParams', TType.STRUCT, 3)
      self.keyGetParams.write(oprot)
      oprot.writeFieldEnd()
    if self.peerAddParams != None:
      oprot.writeFieldBegin('peerAddParams', TType.STRUCT, 4)
      self.peerAddParams.write(oprot)
      oprot.writeFieldEnd()
    if self.peerDelParams != None:
      oprot.writeFieldBegin('peerDelParams', TType.STRUCT, 5)
      self.peerDelParams.write(oprot)
      oprot.writeFieldEnd()
    if self.keyDumpParams != None:
      oprot.writeFieldBegin('keyDumpParams', TType.STRUCT, 6)
      self.keyDumpParams.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.cmd, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    cmd=%s' % (value))
    value = pprint.pformat(self.keySetParams, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    keySetParams=%s' % (value))
    value = pprint.pformat(self.keyGetParams, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    keyGetParams=%s' % (value))
    value = pprint.pformat(self.keyDumpParams, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    keyDumpParams=%s' % (value))
    value = pprint.pformat(self.peerAddParams, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    peerAddParams=%s' % (value))
    value = pprint.pformat(self.peerDelParams, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    peerDelParams=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class Publication:
  """
  Attributes:
   - keyVals
   - expiredKeys
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 2:
        if ftype == TType.MAP:
          self.keyVals = {}
          (_ktype50, _vtype51, _size49 ) = iprot.readMapBegin() 
          if _size49 >= 0:
            for _i53 in six.moves.range(_size49):
              _key54 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val55 = Value()
              _val55.read(iprot)
              self.keyVals[_key54] = _val55
          else: 
            while iprot.peekMap():
              _key56 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val57 = Value()
              _val57.read(iprot)
              self.keyVals[_key56] = _val57
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.expiredKeys = []
          (_etype61, _size58) = iprot.readListBegin()
          if _size58 >= 0:
            for _i62 in six.moves.range(_size58):
              _elem63 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.expiredKeys.append(_elem63)
          else: 
            while iprot.peekList():
              _elem64 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              self.expiredKeys.append(_elem64)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Publication')
    if self.keyVals != None:
      oprot.writeFieldBegin('keyVals', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.keyVals))
      for kiter65,viter66 in self.keyVals.items():
        oprot.writeString(kiter65.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter65, bytes) else oprot.writeString(kiter65)
        viter66.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.expiredKeys != None:
      oprot.writeFieldBegin('expiredKeys', TType.LIST, 3)
      oprot.writeListBegin(TType.STRING, len(self.expiredKeys))
      for iter67 in self.expiredKeys:
        oprot.writeString(iter67.encode('utf-8')) if UTF8STRINGS and not isinstance(iter67, bytes) else oprot.writeString(iter67)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.keyVals, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    keyVals=%s' % (value))
    value = pprint.pformat(self.expiredKeys, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    expiredKeys=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class PeerCmdReply:
  """
  Attributes:
   - peers
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.MAP:
          self.peers = {}
          (_ktype69, _vtype70, _size68 ) = iprot.readMapBegin() 
          if _size68 >= 0:
            for _i72 in six.moves.range(_size68):
              _key73 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val74 = PeerSpec()
              _val74.read(iprot)
              self.peers[_key73] = _val74
          else: 
            while iprot.peekMap():
              _key75 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val76 = PeerSpec()
              _val76.read(iprot)
              self.peers[_key75] = _val76
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('PeerCmdReply')
    if self.peers != None:
      oprot.writeFieldBegin('peers', TType.MAP, 1)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.peers))
      for kiter77,viter78 in self.peers.items():
        oprot.writeString(kiter77.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter77, bytes) else oprot.writeString(kiter77)
        viter78.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.peers, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    peers=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(Value)
Value.thrift_spec = (
  None, # 0
  (1, TType.I64, 'version', None, None, 2, ), # 1
  (2, TType.STRING, 'value', False, None, 1, ), # 2
  (3, TType.STRING, 'originatorId', True, None, 2, ), # 3
  (4, TType.I64, 'ttl', None, None, 2, ), # 4
  (5, TType.I64, 'ttlVersion', None, 0, 2, ), # 5
  (6, TType.I64, 'hash', None, None, 1, ), # 6
)

Value.thrift_struct_annotations = {
}
Value.thrift_field_annotations = {
}

def Value__init__(self, version=None, originatorId=None, value=None, ttl=None, ttlVersion=Value.thrift_spec[5][4], hash=None,):
  self.version = version
  self.originatorId = originatorId
  self.value = value
  self.ttl = ttl
  self.ttlVersion = ttlVersion
  self.hash = hash

Value.__init__ = Value__init__

all_structs.append(KeySetParams)
KeySetParams.thrift_spec = (
  None, # 0
  None, # 1
  (2, TType.MAP, 'keyVals', (TType.STRING,True,TType.STRUCT,[Value, Value.thrift_spec, False]), None, 2, ), # 2
)

KeySetParams.thrift_struct_annotations = {
}
KeySetParams.thrift_field_annotations = {
}

def KeySetParams__init__(self, keyVals=None,):
  self.keyVals = keyVals

KeySetParams.__init__ = KeySetParams__init__

all_structs.append(KeyGetParams)
KeyGetParams.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'keys', (TType.STRING,True), None, 2, ), # 1
)

KeyGetParams.thrift_struct_annotations = {
}
KeyGetParams.thrift_field_annotations = {
}

def KeyGetParams__init__(self, keys=None,):
  self.keys = keys

KeyGetParams.__init__ = KeyGetParams__init__

all_structs.append(KeyDumpParams)
KeyDumpParams.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'prefix', True, None, 2, ), # 1
  (2, TType.MAP, 'keyValHashes', (TType.STRING,True,TType.STRUCT,[Value, Value.thrift_spec, False]), None, 1, ), # 2
)

KeyDumpParams.thrift_struct_annotations = {
}
KeyDumpParams.thrift_field_annotations = {
}

def KeyDumpParams__init__(self, prefix=None, keyValHashes=None,):
  self.prefix = prefix
  self.keyValHashes = keyValHashes

KeyDumpParams.__init__ = KeyDumpParams__init__

all_structs.append(PeerSpec)
PeerSpec.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'pubUrl', True, None, 2, ), # 1
  (2, TType.STRING, 'cmdUrl', True, None, 2, ), # 2
  (3, TType.STRING, 'publicKey', False, None, 2, ), # 3
)

PeerSpec.thrift_struct_annotations = {
}
PeerSpec.thrift_field_annotations = {
}

def PeerSpec__init__(self, pubUrl=None, cmdUrl=None, publicKey=None,):
  self.pubUrl = pubUrl
  self.cmdUrl = cmdUrl
  self.publicKey = publicKey

PeerSpec.__init__ = PeerSpec__init__

all_structs.append(PeerAddParams)
PeerAddParams.thrift_spec = (
  None, # 0
  (1, TType.MAP, 'peers', (TType.STRING,True,TType.STRUCT,[PeerSpec, PeerSpec.thrift_spec, False]), None, 2, ), # 1
)

PeerAddParams.thrift_struct_annotations = {
}
PeerAddParams.thrift_field_annotations = {
}

def PeerAddParams__init__(self, peers=None,):
  self.peers = peers

PeerAddParams.__init__ = PeerAddParams__init__

all_structs.append(PeerDelParams)
PeerDelParams.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'peerNames', (TType.STRING,True), None, 2, ), # 1
)

PeerDelParams.thrift_struct_annotations = {
}
PeerDelParams.thrift_field_annotations = {
}

def PeerDelParams__init__(self, peerNames=None,):
  self.peerNames = peerNames

PeerDelParams.__init__ = PeerDelParams__init__

all_structs.append(Request)
Request.thrift_spec = (
  None, # 0
  (1, TType.I32, 'cmd', Command, None, 2, ), # 1
  (2, TType.STRUCT, 'keySetParams', [KeySetParams, KeySetParams.thrift_spec, False], None, 2, ), # 2
  (3, TType.STRUCT, 'keyGetParams', [KeyGetParams, KeyGetParams.thrift_spec, False], None, 2, ), # 3
  (4, TType.STRUCT, 'peerAddParams', [PeerAddParams, PeerAddParams.thrift_spec, False], None, 2, ), # 4
  (5, TType.STRUCT, 'peerDelParams', [PeerDelParams, PeerDelParams.thrift_spec, False], None, 2, ), # 5
  (6, TType.STRUCT, 'keyDumpParams', [KeyDumpParams, KeyDumpParams.thrift_spec, False], None, 2, ), # 6
)

Request.thrift_struct_annotations = {
}
Request.thrift_field_annotations = {
}

def Request__init__(self, cmd=None, keySetParams=None, keyGetParams=None, keyDumpParams=None, peerAddParams=None, peerDelParams=None,):
  self.cmd = cmd
  self.keySetParams = keySetParams
  self.keyGetParams = keyGetParams
  self.keyDumpParams = keyDumpParams
  self.peerAddParams = peerAddParams
  self.peerDelParams = peerDelParams

Request.__init__ = Request__init__

all_structs.append(Publication)
Publication.thrift_spec = (
  None, # 0
  None, # 1
  (2, TType.MAP, 'keyVals', (TType.STRING,True,TType.STRUCT,[Value, Value.thrift_spec, False]), None, 2, ), # 2
  (3, TType.LIST, 'expiredKeys', (TType.STRING,True), None, 2, ), # 3
)

Publication.thrift_struct_annotations = {
}
Publication.thrift_field_annotations = {
}

def Publication__init__(self, keyVals=None, expiredKeys=None,):
  self.keyVals = keyVals
  self.expiredKeys = expiredKeys

Publication.__init__ = Publication__init__

all_structs.append(PeerCmdReply)
PeerCmdReply.thrift_spec = (
  None, # 0
  (1, TType.MAP, 'peers', (TType.STRING,True,TType.STRUCT,[PeerSpec, PeerSpec.thrift_spec, False]), None, 2, ), # 1
)

PeerCmdReply.thrift_struct_annotations = {
}
PeerCmdReply.thrift_field_annotations = {
}

def PeerCmdReply__init__(self, peers=None,):
  self.peers = peers

PeerCmdReply.__init__ = PeerCmdReply__init__

fix_spec(all_structs)
del all_structs
