#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import six
from thrift.util.Recursive import fix_spec
from thrift.Thrift import *
from thrift.protocol.TProtocol import TProtocolException



import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
try:
  from thrift.protocol import fastproto
except:
  fastproto = None
all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'AddressType', 'Address', 'BinaryAddress', 'IpPrefix', 'UnicastRoute']

class AddressType:
  VUNSPEC = 0
  V4 = 1
  V6 = 2

  _VALUES_TO_NAMES = {
    0: "VUNSPEC",
    1: "V4",
    2: "V6",
  }

  _NAMES_TO_VALUES = {
    "VUNSPEC": 0,
    "V4": 1,
    "V6": 2,
  }

class Address:
  """
  Attributes:
   - addr
   - type
   - port
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.addr = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.port = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.addr == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'addr' was not found in serialized data! Struct: Address")

    if self.type == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'type' was not found in serialized data! Struct: Address")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Address')
    if self.addr != None:
      oprot.writeFieldBegin('addr', TType.STRING, 1)
      oprot.writeString(self.addr.encode('utf-8')) if UTF8STRINGS and not isinstance(self.addr, bytes) else oprot.writeString(self.addr)
      oprot.writeFieldEnd()
    if self.type != None:
      oprot.writeFieldBegin('type', TType.I32, 2)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.port != None and self.port != self.thrift_spec[3][4]:
      oprot.writeFieldBegin('port', TType.I64, 3)
      oprot.writeI64(self.port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.addr, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    addr=%s' % (value))
    value = pprint.pformat(self.type, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    type=%s' % (value))
    value = pprint.pformat(self.port, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    port=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class BinaryAddress:
  """
  Attributes:
   - addr
   - port
   - ifName
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.addr = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.port = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.ifName = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.addr == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'addr' was not found in serialized data! Struct: BinaryAddress")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('BinaryAddress')
    if self.addr != None:
      oprot.writeFieldBegin('addr', TType.STRING, 1)
      oprot.writeString(self.addr)
      oprot.writeFieldEnd()
    if self.port != None and self.port != self.thrift_spec[2][4]:
      oprot.writeFieldBegin('port', TType.I64, 2)
      oprot.writeI64(self.port)
      oprot.writeFieldEnd()
    if self.ifName != None:
      oprot.writeFieldBegin('ifName', TType.STRING, 3)
      oprot.writeString(self.ifName.encode('utf-8')) if UTF8STRINGS and not isinstance(self.ifName, bytes) else oprot.writeString(self.ifName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.addr, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    addr=%s' % (value))
    value = pprint.pformat(self.port, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    port=%s' % (value))
    value = pprint.pformat(self.ifName, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    ifName=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class IpPrefix:
  """
  Attributes:
   - prefixAddress
   - prefixLength
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.prefixAddress = BinaryAddress()
          self.prefixAddress.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.prefixLength = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('IpPrefix')
    if self.prefixAddress != None:
      oprot.writeFieldBegin('prefixAddress', TType.STRUCT, 1)
      self.prefixAddress.write(oprot)
      oprot.writeFieldEnd()
    if self.prefixLength != None:
      oprot.writeFieldBegin('prefixLength', TType.I16, 2)
      oprot.writeI16(self.prefixLength)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.prefixAddress, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    prefixAddress=%s' % (value))
    value = pprint.pformat(self.prefixLength, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    prefixLength=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class UnicastRoute:
  """
  Attributes:
   - dest
   - nexthops
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.dest = IpPrefix()
          self.dest.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.nexthops = []
          (_etype3, _size0) = iprot.readListBegin()
          if _size0 >= 0:
            for _i4 in six.moves.range(_size0):
              _elem5 = BinaryAddress()
              _elem5.read(iprot)
              self.nexthops.append(_elem5)
          else: 
            while iprot.peekList():
              _elem6 = BinaryAddress()
              _elem6.read(iprot)
              self.nexthops.append(_elem6)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.dest == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'dest' was not found in serialized data! Struct: UnicastRoute")

    if self.nexthops == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'nexthops' was not found in serialized data! Struct: UnicastRoute")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('UnicastRoute')
    if self.dest != None:
      oprot.writeFieldBegin('dest', TType.STRUCT, 1)
      self.dest.write(oprot)
      oprot.writeFieldEnd()
    if self.nexthops != None:
      oprot.writeFieldBegin('nexthops', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.nexthops))
      for iter7 in self.nexthops:
        iter7.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.dest, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    dest=%s' % (value))
    value = pprint.pformat(self.nexthops, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    nexthops=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(Address)
Address.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'addr', True, None, 0, ), # 1
  (2, TType.I32, 'type', AddressType, None, 0, ), # 2
  (3, TType.I64, 'port', None, 0, 1, ), # 3
)

Address.thrift_struct_annotations = {
}
Address.thrift_field_annotations = {
}

def Address__init__(self, addr=None, type=None, port=Address.thrift_spec[3][4],):
  self.addr = addr
  self.type = type
  self.port = port

Address.__init__ = Address__init__

all_structs.append(BinaryAddress)
BinaryAddress.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'addr', False, None, 0, ), # 1
  (2, TType.I64, 'port', None, 0, 1, ), # 2
  (3, TType.STRING, 'ifName', True, None, 1, ), # 3
)

BinaryAddress.thrift_struct_annotations = {
}
BinaryAddress.thrift_field_annotations = {
}

def BinaryAddress__init__(self, addr=None, port=BinaryAddress.thrift_spec[2][4], ifName=None,):
  self.addr = addr
  self.port = port
  self.ifName = ifName

BinaryAddress.__init__ = BinaryAddress__init__

all_structs.append(IpPrefix)
IpPrefix.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'prefixAddress', [BinaryAddress, BinaryAddress.thrift_spec, False], None, 2, ), # 1
  (2, TType.I16, 'prefixLength', None, None, 2, ), # 2
)

IpPrefix.thrift_struct_annotations = {
}
IpPrefix.thrift_field_annotations = {
}

def IpPrefix__init__(self, prefixAddress=None, prefixLength=None,):
  self.prefixAddress = prefixAddress
  self.prefixLength = prefixLength

IpPrefix.__init__ = IpPrefix__init__

all_structs.append(UnicastRoute)
UnicastRoute.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'dest', [IpPrefix, IpPrefix.thrift_spec, False], None, 0, ), # 1
  (2, TType.LIST, 'nexthops', (TType.STRUCT,[BinaryAddress, BinaryAddress.thrift_spec, False]), None, 0, ), # 2
)

UnicastRoute.thrift_struct_annotations = {
}
UnicastRoute.thrift_field_annotations = {
}

def UnicastRoute__init__(self, dest=None, nexthops=None,):
  self.dest = dest
  self.nexthops = nexthops

UnicastRoute.__init__ = UnicastRoute__init__

fix_spec(all_structs)
del all_structs
