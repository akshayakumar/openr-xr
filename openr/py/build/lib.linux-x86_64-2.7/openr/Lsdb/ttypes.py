#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import six
from thrift.util.Recursive import fix_spec
from thrift.Thrift import *
from thrift.protocol.TProtocol import TProtocolException


import openr.IpPrefix.ttypes


import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
try:
  from thrift.protocol import fastproto
except:
  fastproto = None
all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

__all__ = ['UTF8STRINGS', 'PrefixType', 'PerfEvent', 'PerfEvents', 'InterfaceInfo', 'InterfaceDatabase', 'Adjacency', 'AdjacencyDatabase', 'PrefixEntry', 'PrefixDatabase']

class PrefixType:
  LOOPBACK = 1
  DEFAULT = 2
  BGP = 3
  PREFIX_ALLOCATOR = 4
  BREEZE = 5
  TYPE_1 = 21
  TYPE_2 = 22
  TYPE_3 = 23
  TYPE_4 = 24
  TYPE_5 = 25

  _VALUES_TO_NAMES = {
    1: "LOOPBACK",
    2: "DEFAULT",
    3: "BGP",
    4: "PREFIX_ALLOCATOR",
    5: "BREEZE",
    21: "TYPE_1",
    22: "TYPE_2",
    23: "TYPE_3",
    24: "TYPE_4",
    25: "TYPE_5",
  }

  _NAMES_TO_VALUES = {
    "LOOPBACK": 1,
    "DEFAULT": 2,
    "BGP": 3,
    "PREFIX_ALLOCATOR": 4,
    "BREEZE": 5,
    "TYPE_1": 21,
    "TYPE_2": 22,
    "TYPE_3": 23,
    "TYPE_4": 24,
    "TYPE_5": 25,
  }

class PerfEvent:
  """
  Attributes:
   - nodeName
   - eventDescr
   - unixTs
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.nodeName = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.eventDescr = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.unixTs = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('PerfEvent')
    if self.nodeName != None:
      oprot.writeFieldBegin('nodeName', TType.STRING, 1)
      oprot.writeString(self.nodeName.encode('utf-8')) if UTF8STRINGS and not isinstance(self.nodeName, bytes) else oprot.writeString(self.nodeName)
      oprot.writeFieldEnd()
    if self.eventDescr != None:
      oprot.writeFieldBegin('eventDescr', TType.STRING, 2)
      oprot.writeString(self.eventDescr.encode('utf-8')) if UTF8STRINGS and not isinstance(self.eventDescr, bytes) else oprot.writeString(self.eventDescr)
      oprot.writeFieldEnd()
    if self.unixTs != None:
      oprot.writeFieldBegin('unixTs', TType.I64, 3)
      oprot.writeI64(self.unixTs)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.nodeName, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    nodeName=%s' % (value))
    value = pprint.pformat(self.eventDescr, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    eventDescr=%s' % (value))
    value = pprint.pformat(self.unixTs, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    unixTs=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class PerfEvents:
  """
  Attributes:
   - events
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.events = []
          (_etype3, _size0) = iprot.readListBegin()
          if _size0 >= 0:
            for _i4 in six.moves.range(_size0):
              _elem5 = PerfEvent()
              _elem5.read(iprot)
              self.events.append(_elem5)
          else: 
            while iprot.peekList():
              _elem6 = PerfEvent()
              _elem6.read(iprot)
              self.events.append(_elem6)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('PerfEvents')
    if self.events != None:
      oprot.writeFieldBegin('events', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.events))
      for iter7 in self.events:
        iter7.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.events, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    events=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class InterfaceInfo:
  """
  Attributes:
   - isUp
   - ifIndex
   - v4Addrs
   - v6LinkLocalAddrs
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.isUp = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.ifIndex = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.v4Addrs = []
          (_etype11, _size8) = iprot.readListBegin()
          if _size8 >= 0:
            for _i12 in six.moves.range(_size8):
              _elem13 = openr.IpPrefix.ttypes.BinaryAddress()
              _elem13.read(iprot)
              self.v4Addrs.append(_elem13)
          else: 
            while iprot.peekList():
              _elem14 = openr.IpPrefix.ttypes.BinaryAddress()
              _elem14.read(iprot)
              self.v4Addrs.append(_elem14)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.v6LinkLocalAddrs = []
          (_etype18, _size15) = iprot.readListBegin()
          if _size15 >= 0:
            for _i19 in six.moves.range(_size15):
              _elem20 = openr.IpPrefix.ttypes.BinaryAddress()
              _elem20.read(iprot)
              self.v6LinkLocalAddrs.append(_elem20)
          else: 
            while iprot.peekList():
              _elem21 = openr.IpPrefix.ttypes.BinaryAddress()
              _elem21.read(iprot)
              self.v6LinkLocalAddrs.append(_elem21)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    if self.isUp == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'isUp' was not found in serialized data! Struct: InterfaceInfo")

    if self.ifIndex == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'ifIndex' was not found in serialized data! Struct: InterfaceInfo")

    if self.v4Addrs == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'v4Addrs' was not found in serialized data! Struct: InterfaceInfo")

    if self.v6LinkLocalAddrs == None:
      raise TProtocolException(TProtocolException.MISSING_REQUIRED_FIELD, "Required field 'v6LinkLocalAddrs' was not found in serialized data! Struct: InterfaceInfo")

    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('InterfaceInfo')
    if self.isUp != None:
      oprot.writeFieldBegin('isUp', TType.BOOL, 1)
      oprot.writeBool(self.isUp)
      oprot.writeFieldEnd()
    if self.ifIndex != None:
      oprot.writeFieldBegin('ifIndex', TType.I64, 2)
      oprot.writeI64(self.ifIndex)
      oprot.writeFieldEnd()
    if self.v4Addrs != None:
      oprot.writeFieldBegin('v4Addrs', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.v4Addrs))
      for iter22 in self.v4Addrs:
        iter22.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.v6LinkLocalAddrs != None:
      oprot.writeFieldBegin('v6LinkLocalAddrs', TType.LIST, 4)
      oprot.writeListBegin(TType.STRUCT, len(self.v6LinkLocalAddrs))
      for iter23 in self.v6LinkLocalAddrs:
        iter23.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.isUp, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    isUp=%s' % (value))
    value = pprint.pformat(self.ifIndex, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    ifIndex=%s' % (value))
    value = pprint.pformat(self.v4Addrs, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    v4Addrs=%s' % (value))
    value = pprint.pformat(self.v6LinkLocalAddrs, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    v6LinkLocalAddrs=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class InterfaceDatabase:
  """
  Attributes:
   - thisNodeName
   - interfaces
   - perfEvents
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.thisNodeName = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.MAP:
          self.interfaces = {}
          (_ktype25, _vtype26, _size24 ) = iprot.readMapBegin() 
          if _size24 >= 0:
            for _i28 in six.moves.range(_size24):
              _key29 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val30 = InterfaceInfo()
              _val30.read(iprot)
              self.interfaces[_key29] = _val30
          else: 
            while iprot.peekMap():
              _key31 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val32 = InterfaceInfo()
              _val32.read(iprot)
              self.interfaces[_key31] = _val32
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.perfEvents = PerfEvents()
          self.perfEvents.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('InterfaceDatabase')
    if self.thisNodeName != None:
      oprot.writeFieldBegin('thisNodeName', TType.STRING, 1)
      oprot.writeString(self.thisNodeName.encode('utf-8')) if UTF8STRINGS and not isinstance(self.thisNodeName, bytes) else oprot.writeString(self.thisNodeName)
      oprot.writeFieldEnd()
    if self.interfaces != None:
      oprot.writeFieldBegin('interfaces', TType.MAP, 2)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.interfaces))
      for kiter33,viter34 in self.interfaces.items():
        oprot.writeString(kiter33.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter33, bytes) else oprot.writeString(kiter33)
        viter34.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.perfEvents != None:
      oprot.writeFieldBegin('perfEvents', TType.STRUCT, 3)
      self.perfEvents.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.thisNodeName, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    thisNodeName=%s' % (value))
    value = pprint.pformat(self.interfaces, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    interfaces=%s' % (value))
    value = pprint.pformat(self.perfEvents, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    perfEvents=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class Adjacency:
  """
  Attributes:
   - otherNodeName
   - ifName
   - nextHopV6
   - nextHopV4
   - metric
   - adjLabel
   - isOverloaded
   - rtt
   - timestamp
   - weight
   - otherIfName
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.otherNodeName = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.ifName = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.nextHopV6 = openr.IpPrefix.ttypes.BinaryAddress()
          self.nextHopV6.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.nextHopV4 = openr.IpPrefix.ttypes.BinaryAddress()
          self.nextHopV4.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.metric = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.adjLabel = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.isOverloaded = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.rtt = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.I64:
          self.weight = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.otherIfName = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('Adjacency')
    if self.otherNodeName != None:
      oprot.writeFieldBegin('otherNodeName', TType.STRING, 1)
      oprot.writeString(self.otherNodeName.encode('utf-8')) if UTF8STRINGS and not isinstance(self.otherNodeName, bytes) else oprot.writeString(self.otherNodeName)
      oprot.writeFieldEnd()
    if self.ifName != None:
      oprot.writeFieldBegin('ifName', TType.STRING, 2)
      oprot.writeString(self.ifName.encode('utf-8')) if UTF8STRINGS and not isinstance(self.ifName, bytes) else oprot.writeString(self.ifName)
      oprot.writeFieldEnd()
    if self.nextHopV6 != None:
      oprot.writeFieldBegin('nextHopV6', TType.STRUCT, 3)
      self.nextHopV6.write(oprot)
      oprot.writeFieldEnd()
    if self.metric != None:
      oprot.writeFieldBegin('metric', TType.I32, 4)
      oprot.writeI32(self.metric)
      oprot.writeFieldEnd()
    if self.nextHopV4 != None:
      oprot.writeFieldBegin('nextHopV4', TType.STRUCT, 5)
      self.nextHopV4.write(oprot)
      oprot.writeFieldEnd()
    if self.adjLabel != None:
      oprot.writeFieldBegin('adjLabel', TType.I32, 6)
      oprot.writeI32(self.adjLabel)
      oprot.writeFieldEnd()
    if self.isOverloaded != None:
      oprot.writeFieldBegin('isOverloaded', TType.BOOL, 7)
      oprot.writeBool(self.isOverloaded)
      oprot.writeFieldEnd()
    if self.rtt != None:
      oprot.writeFieldBegin('rtt', TType.I32, 8)
      oprot.writeI32(self.rtt)
      oprot.writeFieldEnd()
    if self.timestamp != None:
      oprot.writeFieldBegin('timestamp', TType.I64, 9)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.weight != None:
      oprot.writeFieldBegin('weight', TType.I64, 10)
      oprot.writeI64(self.weight)
      oprot.writeFieldEnd()
    if self.otherIfName != None:
      oprot.writeFieldBegin('otherIfName', TType.STRING, 11)
      oprot.writeString(self.otherIfName.encode('utf-8')) if UTF8STRINGS and not isinstance(self.otherIfName, bytes) else oprot.writeString(self.otherIfName)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.otherNodeName, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    otherNodeName=%s' % (value))
    value = pprint.pformat(self.ifName, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    ifName=%s' % (value))
    value = pprint.pformat(self.nextHopV6, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    nextHopV6=%s' % (value))
    value = pprint.pformat(self.nextHopV4, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    nextHopV4=%s' % (value))
    value = pprint.pformat(self.metric, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    metric=%s' % (value))
    value = pprint.pformat(self.adjLabel, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    adjLabel=%s' % (value))
    value = pprint.pformat(self.isOverloaded, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    isOverloaded=%s' % (value))
    value = pprint.pformat(self.rtt, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    rtt=%s' % (value))
    value = pprint.pformat(self.timestamp, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    timestamp=%s' % (value))
    value = pprint.pformat(self.weight, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    weight=%s' % (value))
    value = pprint.pformat(self.otherIfName, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    otherIfName=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class AdjacencyDatabase:
  """
  Attributes:
   - thisNodeName
   - isOverloaded
   - adjacencies
   - nodeLabel
   - perfEvents
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.thisNodeName = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.isOverloaded = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.adjacencies = []
          (_etype38, _size35) = iprot.readListBegin()
          if _size35 >= 0:
            for _i39 in six.moves.range(_size35):
              _elem40 = Adjacency()
              _elem40.read(iprot)
              self.adjacencies.append(_elem40)
          else: 
            while iprot.peekList():
              _elem41 = Adjacency()
              _elem41.read(iprot)
              self.adjacencies.append(_elem41)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.nodeLabel = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.perfEvents = PerfEvents()
          self.perfEvents.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('AdjacencyDatabase')
    if self.thisNodeName != None:
      oprot.writeFieldBegin('thisNodeName', TType.STRING, 1)
      oprot.writeString(self.thisNodeName.encode('utf-8')) if UTF8STRINGS and not isinstance(self.thisNodeName, bytes) else oprot.writeString(self.thisNodeName)
      oprot.writeFieldEnd()
    if self.isOverloaded != None:
      oprot.writeFieldBegin('isOverloaded', TType.BOOL, 2)
      oprot.writeBool(self.isOverloaded)
      oprot.writeFieldEnd()
    if self.adjacencies != None:
      oprot.writeFieldBegin('adjacencies', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.adjacencies))
      for iter42 in self.adjacencies:
        iter42.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.nodeLabel != None:
      oprot.writeFieldBegin('nodeLabel', TType.I32, 4)
      oprot.writeI32(self.nodeLabel)
      oprot.writeFieldEnd()
    if self.perfEvents != None:
      oprot.writeFieldBegin('perfEvents', TType.STRUCT, 5)
      self.perfEvents.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.thisNodeName, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    thisNodeName=%s' % (value))
    value = pprint.pformat(self.isOverloaded, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    isOverloaded=%s' % (value))
    value = pprint.pformat(self.adjacencies, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    adjacencies=%s' % (value))
    value = pprint.pformat(self.nodeLabel, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    nodeLabel=%s' % (value))
    value = pprint.pformat(self.perfEvents, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    perfEvents=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class PrefixEntry:
  """
  Attributes:
   - prefix
   - type
   - data
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.prefix = openr.IpPrefix.ttypes.IpPrefix()
          self.prefix.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.data = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('PrefixEntry')
    if self.prefix != None:
      oprot.writeFieldBegin('prefix', TType.STRUCT, 1)
      self.prefix.write(oprot)
      oprot.writeFieldEnd()
    if self.type != None:
      oprot.writeFieldBegin('type', TType.I32, 2)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.data != None:
      oprot.writeFieldBegin('data', TType.STRING, 3)
      oprot.writeString(self.data)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.prefix, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    prefix=%s' % (value))
    value = pprint.pformat(self.type, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    type=%s' % (value))
    value = pprint.pformat(self.data, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    data=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

class PrefixDatabase:
  """
  Attributes:
   - thisNodeName
   - prefixEntries
   - perfEvents
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.thisNodeName = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.prefixEntries = []
          (_etype46, _size43) = iprot.readListBegin()
          if _size43 >= 0:
            for _i47 in six.moves.range(_size43):
              _elem48 = PrefixEntry()
              _elem48.read(iprot)
              self.prefixEntries.append(_elem48)
          else: 
            while iprot.peekList():
              _elem49 = PrefixEntry()
              _elem49.read(iprot)
              self.prefixEntries.append(_elem49)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.perfEvents = PerfEvents()
          self.perfEvents.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('PrefixDatabase')
    if self.thisNodeName != None:
      oprot.writeFieldBegin('thisNodeName', TType.STRING, 1)
      oprot.writeString(self.thisNodeName.encode('utf-8')) if UTF8STRINGS and not isinstance(self.thisNodeName, bytes) else oprot.writeString(self.thisNodeName)
      oprot.writeFieldEnd()
    if self.prefixEntries != None:
      oprot.writeFieldBegin('prefixEntries', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.prefixEntries))
      for iter50 in self.prefixEntries:
        iter50.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.perfEvents != None:
      oprot.writeFieldBegin('perfEvents', TType.STRUCT, 4)
      self.perfEvents.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.thisNodeName, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    thisNodeName=%s' % (value))
    value = pprint.pformat(self.prefixEntries, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    prefixEntries=%s' % (value))
    value = pprint.pformat(self.perfEvents, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    perfEvents=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(PerfEvent)
PerfEvent.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'nodeName', True, None, 2, ), # 1
  (2, TType.STRING, 'eventDescr', True, None, 2, ), # 2
  (3, TType.I64, 'unixTs', None, 0, 2, ), # 3
)

PerfEvent.thrift_struct_annotations = {
}
PerfEvent.thrift_field_annotations = {
}

def PerfEvent__init__(self, nodeName=None, eventDescr=None, unixTs=PerfEvent.thrift_spec[3][4],):
  self.nodeName = nodeName
  self.eventDescr = eventDescr
  self.unixTs = unixTs

PerfEvent.__init__ = PerfEvent__init__

all_structs.append(PerfEvents)
PerfEvents.thrift_spec = (
  None, # 0
  (1, TType.LIST, 'events', (TType.STRUCT,[PerfEvent, PerfEvent.thrift_spec, False]), None, 2, ), # 1
)

PerfEvents.thrift_struct_annotations = {
}
PerfEvents.thrift_field_annotations = {
}

def PerfEvents__init__(self, events=None,):
  self.events = events

PerfEvents.__init__ = PerfEvents__init__

all_structs.append(InterfaceInfo)
InterfaceInfo.thrift_spec = (
  None, # 0
  (1, TType.BOOL, 'isUp', None, None, 0, ), # 1
  (2, TType.I64, 'ifIndex', None, None, 0, ), # 2
  (3, TType.LIST, 'v4Addrs', (TType.STRUCT,[openr.IpPrefix.ttypes.BinaryAddress, openr.IpPrefix.ttypes.BinaryAddress.thrift_spec, False]), None, 0, ), # 3
  (4, TType.LIST, 'v6LinkLocalAddrs', (TType.STRUCT,[openr.IpPrefix.ttypes.BinaryAddress, openr.IpPrefix.ttypes.BinaryAddress.thrift_spec, False]), None, 0, ), # 4
)

InterfaceInfo.thrift_struct_annotations = {
}
InterfaceInfo.thrift_field_annotations = {
}

def InterfaceInfo__init__(self, isUp=None, ifIndex=None, v4Addrs=None, v6LinkLocalAddrs=None,):
  self.isUp = isUp
  self.ifIndex = ifIndex
  self.v4Addrs = v4Addrs
  self.v6LinkLocalAddrs = v6LinkLocalAddrs

InterfaceInfo.__init__ = InterfaceInfo__init__

all_structs.append(InterfaceDatabase)
InterfaceDatabase.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'thisNodeName', True, None, 2, ), # 1
  (2, TType.MAP, 'interfaces', (TType.STRING,True,TType.STRUCT,[InterfaceInfo, InterfaceInfo.thrift_spec, False]), None, 2, ), # 2
  (3, TType.STRUCT, 'perfEvents', [PerfEvents, PerfEvents.thrift_spec, False], None, 1, ), # 3
)

InterfaceDatabase.thrift_struct_annotations = {
}
InterfaceDatabase.thrift_field_annotations = {
}

def InterfaceDatabase__init__(self, thisNodeName=None, interfaces=None, perfEvents=None,):
  self.thisNodeName = thisNodeName
  self.interfaces = interfaces
  self.perfEvents = perfEvents

InterfaceDatabase.__init__ = InterfaceDatabase__init__

all_structs.append(Adjacency)
Adjacency.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'otherNodeName', True, None, 2, ), # 1
  (2, TType.STRING, 'ifName', True, None, 2, ), # 2
  (3, TType.STRUCT, 'nextHopV6', [openr.IpPrefix.ttypes.BinaryAddress, openr.IpPrefix.ttypes.BinaryAddress.thrift_spec, False], None, 2, ), # 3
  (4, TType.I32, 'metric', None, None, 2, ), # 4
  (5, TType.STRUCT, 'nextHopV4', [openr.IpPrefix.ttypes.BinaryAddress, openr.IpPrefix.ttypes.BinaryAddress.thrift_spec, False], None, 2, ), # 5
  (6, TType.I32, 'adjLabel', None, 0, 2, ), # 6
  (7, TType.BOOL, 'isOverloaded', None, False, 2, ), # 7
  (8, TType.I32, 'rtt', None, None, 2, ), # 8
  (9, TType.I64, 'timestamp', None, None, 2, ), # 9
  (10, TType.I64, 'weight', None, 1, 2, ), # 10
  (11, TType.STRING, 'otherIfName', True, "", 2, ), # 11
)

Adjacency.thrift_struct_annotations = {
}
Adjacency.thrift_field_annotations = {
}

def Adjacency__init__(self, otherNodeName=None, ifName=None, nextHopV6=None, nextHopV4=None, metric=None, adjLabel=Adjacency.thrift_spec[6][4], isOverloaded=Adjacency.thrift_spec[7][4], rtt=None, timestamp=None, weight=Adjacency.thrift_spec[10][4], otherIfName=Adjacency.thrift_spec[11][4],):
  self.otherNodeName = otherNodeName
  self.ifName = ifName
  self.nextHopV6 = nextHopV6
  self.nextHopV4 = nextHopV4
  self.metric = metric
  self.adjLabel = adjLabel
  self.isOverloaded = isOverloaded
  self.rtt = rtt
  self.timestamp = timestamp
  self.weight = weight
  self.otherIfName = otherIfName

Adjacency.__init__ = Adjacency__init__

all_structs.append(AdjacencyDatabase)
AdjacencyDatabase.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'thisNodeName', True, None, 2, ), # 1
  (2, TType.BOOL, 'isOverloaded', None, False, 2, ), # 2
  (3, TType.LIST, 'adjacencies', (TType.STRUCT,[Adjacency, Adjacency.thrift_spec, False]), None, 2, ), # 3
  (4, TType.I32, 'nodeLabel', None, None, 2, ), # 4
  (5, TType.STRUCT, 'perfEvents', [PerfEvents, PerfEvents.thrift_spec, False], None, 1, ), # 5
)

AdjacencyDatabase.thrift_struct_annotations = {
}
AdjacencyDatabase.thrift_field_annotations = {
}

def AdjacencyDatabase__init__(self, thisNodeName=None, isOverloaded=AdjacencyDatabase.thrift_spec[2][4], adjacencies=None, nodeLabel=None, perfEvents=None,):
  self.thisNodeName = thisNodeName
  self.isOverloaded = isOverloaded
  self.adjacencies = adjacencies
  self.nodeLabel = nodeLabel
  self.perfEvents = perfEvents

AdjacencyDatabase.__init__ = AdjacencyDatabase__init__

all_structs.append(PrefixEntry)
PrefixEntry.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'prefix', [openr.IpPrefix.ttypes.IpPrefix, openr.IpPrefix.ttypes.IpPrefix.thrift_spec, False], None, 2, ), # 1
  (2, TType.I32, 'type', PrefixType, None, 2, ), # 2
  (3, TType.STRING, 'data', False, None, 2, ), # 3
)

PrefixEntry.thrift_struct_annotations = {
}
PrefixEntry.thrift_field_annotations = {
}

def PrefixEntry__init__(self, prefix=None, type=None, data=None,):
  self.prefix = prefix
  self.type = type
  self.data = data

PrefixEntry.__init__ = PrefixEntry__init__

all_structs.append(PrefixDatabase)
PrefixDatabase.thrift_spec = (
  None, # 0
  (1, TType.STRING, 'thisNodeName', True, None, 2, ), # 1
  None, # 2
  (3, TType.LIST, 'prefixEntries', (TType.STRUCT,[PrefixEntry, PrefixEntry.thrift_spec, False]), None, 2, ), # 3
  (4, TType.STRUCT, 'perfEvents', [PerfEvents, PerfEvents.thrift_spec, False], None, 1, ), # 4
)

PrefixDatabase.thrift_struct_annotations = {
}
PrefixDatabase.thrift_field_annotations = {
}

def PrefixDatabase__init__(self, thisNodeName=None, prefixEntries=None, perfEvents=None,):
  self.thisNodeName = thisNodeName
  self.prefixEntries = prefixEntries
  self.perfEvents = perfEvents

PrefixDatabase.__init__ = PrefixDatabase__init__

fix_spec(all_structs)
del all_structs
