#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from __future__ import absolute_import
import six
from thrift.util.Recursive import fix_spec
from thrift.Thrift import *
from thrift.protocol.TProtocol import TProtocolException


from .ttypes import *
import openr.IpPrefix.ttypes

from thrift.Thrift import TProcessor
import pprint
import warnings
from thrift import Thrift
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.protocol import TCompactProtocol
from thrift.protocol import THeaderProtocol
try:
  from thrift.protocol import fastproto
except:
  fastproto = None

all_structs = []
UTF8STRINGS = bool(0) or sys.version_info.major >= 3

from thrift.util.Decorators import *

class Iface:
  """
  Interface to on-box Fib.
  """
  def addUnicastRoute(self, clientId=None, route=None):
    """
    Parameters:
     - clientId
     - route
    """
    pass

  def deleteUnicastRoute(self, clientId=None, prefix=None):
    """
    Parameters:
     - clientId
     - prefix
    """
    pass

  def addUnicastRoutes(self, clientId=None, routes=None):
    """
    Parameters:
     - clientId
     - routes
    """
    pass

  def deleteUnicastRoutes(self, clientId=None, prefixes=None):
    """
    Parameters:
     - clientId
     - prefixes
    """
    pass

  def syncFib(self, clientId=None, routes=None):
    """
    Parameters:
     - clientId
     - routes
    """
    pass

  def periodicKeepAlive(self, clientId=None):
    """
    DEPRECATED ... Use `aliveSince` API instead
    openr should periodically call this to let Fib know that it is alive
    
    Parameters:
     - clientId
    """
    pass

  def aliveSince(self, ):
    """
    Returns the unix time that the service has been running since
    """
    pass

  def getCounters(self, ):
    pass

  def getRouteTableByClient(self, clientId=None):
    """
    Parameters:
     - clientId
    """
    pass


class ContextIface:
  """
  Interface to on-box Fib.
  """
  def addUnicastRoute(self, handler_ctx, clientId=None, route=None):
    """
    Parameters:
     - clientId
     - route
    """
    pass

  def deleteUnicastRoute(self, handler_ctx, clientId=None, prefix=None):
    """
    Parameters:
     - clientId
     - prefix
    """
    pass

  def addUnicastRoutes(self, handler_ctx, clientId=None, routes=None):
    """
    Parameters:
     - clientId
     - routes
    """
    pass

  def deleteUnicastRoutes(self, handler_ctx, clientId=None, prefixes=None):
    """
    Parameters:
     - clientId
     - prefixes
    """
    pass

  def syncFib(self, handler_ctx, clientId=None, routes=None):
    """
    Parameters:
     - clientId
     - routes
    """
    pass

  def periodicKeepAlive(self, handler_ctx, clientId=None):
    """
    DEPRECATED ... Use `aliveSince` API instead
    openr should periodically call this to let Fib know that it is alive
    
    Parameters:
     - clientId
    """
    pass

  def aliveSince(self, handler_ctx, ):
    """
    Returns the unix time that the service has been running since
    """
    pass

  def getCounters(self, handler_ctx, ):
    pass

  def getRouteTableByClient(self, handler_ctx, clientId=None):
    """
    Parameters:
     - clientId
    """
    pass


# HELPER FUNCTIONS AND STRUCTURES

class addUnicastRoute_args:
  """
  Attributes:
   - clientId
   - route
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.clientId = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.route = openr.IpPrefix.ttypes.UnicastRoute()
          self.route.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('addUnicastRoute_args')
    if self.clientId != None:
      oprot.writeFieldBegin('clientId', TType.I16, 1)
      oprot.writeI16(self.clientId)
      oprot.writeFieldEnd()
    if self.route != None:
      oprot.writeFieldBegin('route', TType.STRUCT, 2)
      self.route.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.clientId, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    clientId=%s' % (value))
    value = pprint.pformat(self.route, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    route=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(addUnicastRoute_args)
addUnicastRoute_args.thrift_spec = (
  None, # 0
  (1, TType.I16, 'clientId', None, None, 2, ), # 1
  (2, TType.STRUCT, 'route', [openr.IpPrefix.ttypes.UnicastRoute, openr.IpPrefix.ttypes.UnicastRoute.thrift_spec, False], None, 2, ), # 2
)

addUnicastRoute_args.thrift_struct_annotations = {
}
addUnicastRoute_args.thrift_field_annotations = {
}

def addUnicastRoute_args__init__(self, clientId=None, route=None,):
  self.clientId = clientId
  self.route = route

addUnicastRoute_args.__init__ = addUnicastRoute_args__init__

class addUnicastRoute_result:
  """
  Attributes:
   - error
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.error = PlatformError()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('addUnicastRoute_result')
    if self.error != None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.error, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    error=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(addUnicastRoute_result)
addUnicastRoute_result.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'error', [PlatformError, PlatformError.thrift_spec, False], None, 2, ), # 1
)

addUnicastRoute_result.thrift_struct_annotations = {
}
addUnicastRoute_result.thrift_field_annotations = {
}

def addUnicastRoute_result__init__(self, error=None,):
  self.error = error

addUnicastRoute_result.__init__ = addUnicastRoute_result__init__

class deleteUnicastRoute_args:
  """
  Attributes:
   - clientId
   - prefix
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.clientId = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.prefix = openr.IpPrefix.ttypes.IpPrefix()
          self.prefix.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('deleteUnicastRoute_args')
    if self.clientId != None:
      oprot.writeFieldBegin('clientId', TType.I16, 1)
      oprot.writeI16(self.clientId)
      oprot.writeFieldEnd()
    if self.prefix != None:
      oprot.writeFieldBegin('prefix', TType.STRUCT, 2)
      self.prefix.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.clientId, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    clientId=%s' % (value))
    value = pprint.pformat(self.prefix, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    prefix=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(deleteUnicastRoute_args)
deleteUnicastRoute_args.thrift_spec = (
  None, # 0
  (1, TType.I16, 'clientId', None, None, 2, ), # 1
  (2, TType.STRUCT, 'prefix', [openr.IpPrefix.ttypes.IpPrefix, openr.IpPrefix.ttypes.IpPrefix.thrift_spec, False], None, 2, ), # 2
)

deleteUnicastRoute_args.thrift_struct_annotations = {
}
deleteUnicastRoute_args.thrift_field_annotations = {
}

def deleteUnicastRoute_args__init__(self, clientId=None, prefix=None,):
  self.clientId = clientId
  self.prefix = prefix

deleteUnicastRoute_args.__init__ = deleteUnicastRoute_args__init__

class deleteUnicastRoute_result:
  """
  Attributes:
   - error
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.error = PlatformError()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('deleteUnicastRoute_result')
    if self.error != None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.error, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    error=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(deleteUnicastRoute_result)
deleteUnicastRoute_result.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'error', [PlatformError, PlatformError.thrift_spec, False], None, 2, ), # 1
)

deleteUnicastRoute_result.thrift_struct_annotations = {
}
deleteUnicastRoute_result.thrift_field_annotations = {
}

def deleteUnicastRoute_result__init__(self, error=None,):
  self.error = error

deleteUnicastRoute_result.__init__ = deleteUnicastRoute_result__init__

class addUnicastRoutes_args:
  """
  Attributes:
   - clientId
   - routes
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.clientId = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.routes = []
          (_etype27, _size24) = iprot.readListBegin()
          if _size24 >= 0:
            for _i28 in six.moves.range(_size24):
              _elem29 = openr.IpPrefix.ttypes.UnicastRoute()
              _elem29.read(iprot)
              self.routes.append(_elem29)
          else: 
            while iprot.peekList():
              _elem30 = openr.IpPrefix.ttypes.UnicastRoute()
              _elem30.read(iprot)
              self.routes.append(_elem30)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('addUnicastRoutes_args')
    if self.clientId != None:
      oprot.writeFieldBegin('clientId', TType.I16, 1)
      oprot.writeI16(self.clientId)
      oprot.writeFieldEnd()
    if self.routes != None:
      oprot.writeFieldBegin('routes', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.routes))
      for iter31 in self.routes:
        iter31.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.clientId, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    clientId=%s' % (value))
    value = pprint.pformat(self.routes, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    routes=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(addUnicastRoutes_args)
addUnicastRoutes_args.thrift_spec = (
  None, # 0
  (1, TType.I16, 'clientId', None, None, 2, ), # 1
  (2, TType.LIST, 'routes', (TType.STRUCT,[openr.IpPrefix.ttypes.UnicastRoute, openr.IpPrefix.ttypes.UnicastRoute.thrift_spec, False]), None, 2, ), # 2
)

addUnicastRoutes_args.thrift_struct_annotations = {
}
addUnicastRoutes_args.thrift_field_annotations = {
}

def addUnicastRoutes_args__init__(self, clientId=None, routes=None,):
  self.clientId = clientId
  self.routes = routes

addUnicastRoutes_args.__init__ = addUnicastRoutes_args__init__

class addUnicastRoutes_result:
  """
  Attributes:
   - error
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.error = PlatformError()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('addUnicastRoutes_result')
    if self.error != None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.error, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    error=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(addUnicastRoutes_result)
addUnicastRoutes_result.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'error', [PlatformError, PlatformError.thrift_spec, False], None, 2, ), # 1
)

addUnicastRoutes_result.thrift_struct_annotations = {
}
addUnicastRoutes_result.thrift_field_annotations = {
}

def addUnicastRoutes_result__init__(self, error=None,):
  self.error = error

addUnicastRoutes_result.__init__ = addUnicastRoutes_result__init__

class deleteUnicastRoutes_args:
  """
  Attributes:
   - clientId
   - prefixes
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.clientId = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.prefixes = []
          (_etype35, _size32) = iprot.readListBegin()
          if _size32 >= 0:
            for _i36 in six.moves.range(_size32):
              _elem37 = openr.IpPrefix.ttypes.IpPrefix()
              _elem37.read(iprot)
              self.prefixes.append(_elem37)
          else: 
            while iprot.peekList():
              _elem38 = openr.IpPrefix.ttypes.IpPrefix()
              _elem38.read(iprot)
              self.prefixes.append(_elem38)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('deleteUnicastRoutes_args')
    if self.clientId != None:
      oprot.writeFieldBegin('clientId', TType.I16, 1)
      oprot.writeI16(self.clientId)
      oprot.writeFieldEnd()
    if self.prefixes != None:
      oprot.writeFieldBegin('prefixes', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.prefixes))
      for iter39 in self.prefixes:
        iter39.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.clientId, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    clientId=%s' % (value))
    value = pprint.pformat(self.prefixes, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    prefixes=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(deleteUnicastRoutes_args)
deleteUnicastRoutes_args.thrift_spec = (
  None, # 0
  (1, TType.I16, 'clientId', None, None, 2, ), # 1
  (2, TType.LIST, 'prefixes', (TType.STRUCT,[openr.IpPrefix.ttypes.IpPrefix, openr.IpPrefix.ttypes.IpPrefix.thrift_spec, False]), None, 2, ), # 2
)

deleteUnicastRoutes_args.thrift_struct_annotations = {
}
deleteUnicastRoutes_args.thrift_field_annotations = {
}

def deleteUnicastRoutes_args__init__(self, clientId=None, prefixes=None,):
  self.clientId = clientId
  self.prefixes = prefixes

deleteUnicastRoutes_args.__init__ = deleteUnicastRoutes_args__init__

class deleteUnicastRoutes_result:
  """
  Attributes:
   - error
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.error = PlatformError()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('deleteUnicastRoutes_result')
    if self.error != None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.error, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    error=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(deleteUnicastRoutes_result)
deleteUnicastRoutes_result.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'error', [PlatformError, PlatformError.thrift_spec, False], None, 2, ), # 1
)

deleteUnicastRoutes_result.thrift_struct_annotations = {
}
deleteUnicastRoutes_result.thrift_field_annotations = {
}

def deleteUnicastRoutes_result__init__(self, error=None,):
  self.error = error

deleteUnicastRoutes_result.__init__ = deleteUnicastRoutes_result__init__

class syncFib_args:
  """
  Attributes:
   - clientId
   - routes
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.clientId = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.routes = []
          (_etype43, _size40) = iprot.readListBegin()
          if _size40 >= 0:
            for _i44 in six.moves.range(_size40):
              _elem45 = openr.IpPrefix.ttypes.UnicastRoute()
              _elem45.read(iprot)
              self.routes.append(_elem45)
          else: 
            while iprot.peekList():
              _elem46 = openr.IpPrefix.ttypes.UnicastRoute()
              _elem46.read(iprot)
              self.routes.append(_elem46)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('syncFib_args')
    if self.clientId != None:
      oprot.writeFieldBegin('clientId', TType.I16, 1)
      oprot.writeI16(self.clientId)
      oprot.writeFieldEnd()
    if self.routes != None:
      oprot.writeFieldBegin('routes', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.routes))
      for iter47 in self.routes:
        iter47.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.clientId, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    clientId=%s' % (value))
    value = pprint.pformat(self.routes, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    routes=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(syncFib_args)
syncFib_args.thrift_spec = (
  None, # 0
  (1, TType.I16, 'clientId', None, None, 2, ), # 1
  (2, TType.LIST, 'routes', (TType.STRUCT,[openr.IpPrefix.ttypes.UnicastRoute, openr.IpPrefix.ttypes.UnicastRoute.thrift_spec, False]), None, 2, ), # 2
)

syncFib_args.thrift_struct_annotations = {
}
syncFib_args.thrift_field_annotations = {
}

def syncFib_args__init__(self, clientId=None, routes=None,):
  self.clientId = clientId
  self.routes = routes

syncFib_args.__init__ = syncFib_args__init__

class syncFib_result:
  """
  Attributes:
   - error
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.error = PlatformError()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('syncFib_result')
    if self.error != None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.error, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    error=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(syncFib_result)
syncFib_result.thrift_spec = (
  None, # 0
  (1, TType.STRUCT, 'error', [PlatformError, PlatformError.thrift_spec, False], None, 2, ), # 1
)

syncFib_result.thrift_struct_annotations = {
}
syncFib_result.thrift_field_annotations = {
}

def syncFib_result__init__(self, error=None,):
  self.error = error

syncFib_result.__init__ = syncFib_result__init__

class periodicKeepAlive_args:
  """
  Attributes:
   - clientId
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.clientId = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('periodicKeepAlive_args')
    if self.clientId != None:
      oprot.writeFieldBegin('clientId', TType.I16, 1)
      oprot.writeI16(self.clientId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.clientId, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    clientId=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(periodicKeepAlive_args)
periodicKeepAlive_args.thrift_spec = (
  None, # 0
  (1, TType.I16, 'clientId', None, None, 2, ), # 1
)

periodicKeepAlive_args.thrift_struct_annotations = {
}
periodicKeepAlive_args.thrift_field_annotations = {
}

def periodicKeepAlive_args__init__(self, clientId=None,):
  self.clientId = clientId

periodicKeepAlive_args.__init__ = periodicKeepAlive_args__init__

class periodicKeepAlive_result:
  """
  Attributes:
   - success
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('periodicKeepAlive_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.success, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    success=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(periodicKeepAlive_result)
periodicKeepAlive_result.thrift_spec = (
  (0, TType.I64, 'success', None, None, 2, ), # 0
)

periodicKeepAlive_result.thrift_struct_annotations = {
}
periodicKeepAlive_result.thrift_field_annotations = {
}

def periodicKeepAlive_result__init__(self, success=None,):
  self.success = success

periodicKeepAlive_result.__init__ = periodicKeepAlive_result__init__

class aliveSince_args:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('aliveSince_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(aliveSince_args)
aliveSince_args.thrift_spec = (
)

aliveSince_args.thrift_struct_annotations = {
}
aliveSince_args.thrift_field_annotations = {
}

class aliveSince_result:
  """
  Attributes:
   - success
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.I64:
          self.success = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('aliveSince_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.I64, 0)
      oprot.writeI64(self.success)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.success, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    success=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(aliveSince_result)
aliveSince_result.thrift_spec = (
  (0, TType.I64, 'success', None, None, 2, ), # 0
)

aliveSince_result.thrift_struct_annotations = {
}
aliveSince_result.thrift_field_annotations = {
}

def aliveSince_result__init__(self, success=None,):
  self.success = success

aliveSince_result.__init__ = aliveSince_result__init__

class getCounters_args:

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('getCounters_args')
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(getCounters_args)
getCounters_args.thrift_spec = (
)

getCounters_args.thrift_struct_annotations = {
}
getCounters_args.thrift_field_annotations = {
}

class getCounters_result:
  """
  Attributes:
   - success
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.MAP:
          self.success = {}
          (_ktype49, _vtype50, _size48 ) = iprot.readMapBegin() 
          if _size48 >= 0:
            for _i52 in six.moves.range(_size48):
              _key53 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val54 = iprot.readI64()
              self.success[_key53] = _val54
          else: 
            while iprot.peekMap():
              _key55 = iprot.readString().decode('utf-8') if UTF8STRINGS else iprot.readString()
              _val56 = iprot.readI64()
              self.success[_key55] = _val56
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('getCounters_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.MAP, 0)
      oprot.writeMapBegin(TType.STRING, TType.I64, len(self.success))
      for kiter57,viter58 in self.success.items():
        oprot.writeString(kiter57.encode('utf-8')) if UTF8STRINGS and not isinstance(kiter57, bytes) else oprot.writeString(kiter57)
        oprot.writeI64(viter58)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.success, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    success=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(getCounters_result)
getCounters_result.thrift_spec = (
  (0, TType.MAP, 'success', (TType.STRING,True,TType.I64,None), None, 2, ), # 0
)

getCounters_result.thrift_struct_annotations = {
}
getCounters_result.thrift_field_annotations = {
}

def getCounters_result__init__(self, success=None,):
  self.success = success

getCounters_result.__init__ = getCounters_result__init__

class getRouteTableByClient_args:
  """
  Attributes:
   - clientId
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.clientId = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('getRouteTableByClient_args')
    if self.clientId != None:
      oprot.writeFieldBegin('clientId', TType.I16, 1)
      oprot.writeI16(self.clientId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.clientId, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    clientId=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(getRouteTableByClient_args)
getRouteTableByClient_args.thrift_spec = (
  None, # 0
  (1, TType.I16, 'clientId', None, None, 2, ), # 1
)

getRouteTableByClient_args.thrift_struct_annotations = {
}
getRouteTableByClient_args.thrift_field_annotations = {
}

def getRouteTableByClient_args__init__(self, clientId=None,):
  self.clientId = clientId

getRouteTableByClient_args.__init__ = getRouteTableByClient_args__init__

class getRouteTableByClient_result:
  """
  Attributes:
   - success
   - error
  """

  thrift_spec = None
  thrift_field_annotations = None
  thrift_struct_annotations = None
  __init__ = None
  @staticmethod
  def isUnion():
    return False

  def read(self, iprot):
    if (isinstance(iprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0)
      self.checkRequired()
      return
    if (isinstance(iprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(iprot, THeaderProtocol.THeaderProtocolAccelerate) and iprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastproto is not None:
      fastproto.decode(self, iprot.trans, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2)
      self.checkRequired()
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 0:
        if ftype == TType.LIST:
          self.success = []
          (_etype62, _size59) = iprot.readListBegin()
          if _size59 >= 0:
            for _i63 in six.moves.range(_size59):
              _elem64 = openr.IpPrefix.ttypes.UnicastRoute()
              _elem64.read(iprot)
              self.success.append(_elem64)
          else: 
            while iprot.peekList():
              _elem65 = openr.IpPrefix.ttypes.UnicastRoute()
              _elem65.read(iprot)
              self.success.append(_elem65)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 1:
        if ftype == TType.STRUCT:
          self.error = PlatformError()
          self.error.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()
    self.checkRequired()

  def checkRequired(self):
    return

  def write(self, oprot):
    if (isinstance(oprot, TBinaryProtocol.TBinaryProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_BINARY_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=0))
      return
    if (isinstance(oprot, TCompactProtocol.TCompactProtocolAccelerated) or (isinstance(oprot, THeaderProtocol.THeaderProtocolAccelerate) and oprot.get_protocol_id() == THeaderProtocol.THeaderProtocol.T_COMPACT_PROTOCOL)) and self.thrift_spec is not None and fastproto is not None:
      oprot.trans.write(fastproto.encode(self, [self.__class__, self.thrift_spec, False], utf8strings=UTF8STRINGS, protoid=2))
      return
    oprot.writeStructBegin('getRouteTableByClient_result')
    if self.success != None:
      oprot.writeFieldBegin('success', TType.LIST, 0)
      oprot.writeListBegin(TType.STRUCT, len(self.success))
      for iter66 in self.success:
        iter66.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.error != None:
      oprot.writeFieldBegin('error', TType.STRUCT, 1)
      self.error.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def __repr__(self):
    L = []
    padding = ' ' * 4
    value = pprint.pformat(self.success, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    success=%s' % (value))
    value = pprint.pformat(self.error, indent=0)
    value = padding.join(value.splitlines(True))
    L.append('    error=%s' % (value))
    return "%s(\n%s)" % (self.__class__.__name__, ",\n".join(L))

  def __eq__(self, other):
    if not isinstance(other, self.__class__):
      return False

    return self.__dict__ == other.__dict__ 

  def __ne__(self, other):
    return not (self == other)

  # Override the __hash__ function for Python3 - t10434117
  if not six.PY2:
    __hash__ = object.__hash__

all_structs.append(getRouteTableByClient_result)
getRouteTableByClient_result.thrift_spec = (
  (0, TType.LIST, 'success', (TType.STRUCT,[openr.IpPrefix.ttypes.UnicastRoute, openr.IpPrefix.ttypes.UnicastRoute.thrift_spec, False]), None, 2, ), # 0
  (1, TType.STRUCT, 'error', [PlatformError, PlatformError.thrift_spec, False], None, 2, ), # 1
)

getRouteTableByClient_result.thrift_struct_annotations = {
}
getRouteTableByClient_result.thrift_field_annotations = {
}

def getRouteTableByClient_result__init__(self, success=None, error=None,):
  self.success = success
  self.error = error

getRouteTableByClient_result.__init__ = getRouteTableByClient_result__init__

class Client(Iface):
  """
  Interface to on-box Fib.
  """
  def __enter__(self):
    return self

  def __exit__(self, type, value, tb):
    self._iprot.trans.close()
    if self._iprot is not self._oprot:
      self._oprot.trans.close()

  def __init__(self, iprot, oprot=None):
    self._iprot = self._oprot = iprot
    if oprot != None:
      self._oprot = oprot
    self._seqid = 0

  def addUnicastRoute(self, clientId=None, route=None):
    """
    Parameters:
     - clientId
     - route
    """
    self.send_addUnicastRoute(clientId, route)
    self.recv_addUnicastRoute()

  def send_addUnicastRoute(self, clientId=None, route=None):
    self._oprot.writeMessageBegin('addUnicastRoute', TMessageType.CALL, self._seqid)
    args = addUnicastRoute_args()
    args.clientId = clientId
    args.route = route
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_addUnicastRoute(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = addUnicastRoute_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.error != None:
      raise result.error
    return

  def deleteUnicastRoute(self, clientId=None, prefix=None):
    """
    Parameters:
     - clientId
     - prefix
    """
    self.send_deleteUnicastRoute(clientId, prefix)
    self.recv_deleteUnicastRoute()

  def send_deleteUnicastRoute(self, clientId=None, prefix=None):
    self._oprot.writeMessageBegin('deleteUnicastRoute', TMessageType.CALL, self._seqid)
    args = deleteUnicastRoute_args()
    args.clientId = clientId
    args.prefix = prefix
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_deleteUnicastRoute(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = deleteUnicastRoute_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.error != None:
      raise result.error
    return

  def addUnicastRoutes(self, clientId=None, routes=None):
    """
    Parameters:
     - clientId
     - routes
    """
    self.send_addUnicastRoutes(clientId, routes)
    self.recv_addUnicastRoutes()

  def send_addUnicastRoutes(self, clientId=None, routes=None):
    self._oprot.writeMessageBegin('addUnicastRoutes', TMessageType.CALL, self._seqid)
    args = addUnicastRoutes_args()
    args.clientId = clientId
    args.routes = routes
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_addUnicastRoutes(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = addUnicastRoutes_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.error != None:
      raise result.error
    return

  def deleteUnicastRoutes(self, clientId=None, prefixes=None):
    """
    Parameters:
     - clientId
     - prefixes
    """
    self.send_deleteUnicastRoutes(clientId, prefixes)
    self.recv_deleteUnicastRoutes()

  def send_deleteUnicastRoutes(self, clientId=None, prefixes=None):
    self._oprot.writeMessageBegin('deleteUnicastRoutes', TMessageType.CALL, self._seqid)
    args = deleteUnicastRoutes_args()
    args.clientId = clientId
    args.prefixes = prefixes
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_deleteUnicastRoutes(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = deleteUnicastRoutes_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.error != None:
      raise result.error
    return

  def syncFib(self, clientId=None, routes=None):
    """
    Parameters:
     - clientId
     - routes
    """
    self.send_syncFib(clientId, routes)
    self.recv_syncFib()

  def send_syncFib(self, clientId=None, routes=None):
    self._oprot.writeMessageBegin('syncFib', TMessageType.CALL, self._seqid)
    args = syncFib_args()
    args.clientId = clientId
    args.routes = routes
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_syncFib(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = syncFib_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.error != None:
      raise result.error
    return

  def periodicKeepAlive(self, clientId=None):
    """
    DEPRECATED ... Use `aliveSince` API instead
    openr should periodically call this to let Fib know that it is alive
    
    Parameters:
     - clientId
    """
    self.send_periodicKeepAlive(clientId)
    return self.recv_periodicKeepAlive()

  def send_periodicKeepAlive(self, clientId=None):
    self._oprot.writeMessageBegin('periodicKeepAlive', TMessageType.CALL, self._seqid)
    args = periodicKeepAlive_args()
    args.clientId = clientId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_periodicKeepAlive(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = periodicKeepAlive_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "periodicKeepAlive failed: unknown result");

  def aliveSince(self, ):
    """
    Returns the unix time that the service has been running since
    """
    self.send_aliveSince()
    return self.recv_aliveSince()

  def send_aliveSince(self, ):
    self._oprot.writeMessageBegin('aliveSince', TMessageType.CALL, self._seqid)
    args = aliveSince_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_aliveSince(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = aliveSince_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "aliveSince failed: unknown result");

  def getCounters(self, ):
    self.send_getCounters()
    return self.recv_getCounters()

  def send_getCounters(self, ):
    self._oprot.writeMessageBegin('getCounters', TMessageType.CALL, self._seqid)
    args = getCounters_args()
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getCounters(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getCounters_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getCounters failed: unknown result");

  def getRouteTableByClient(self, clientId=None):
    """
    Parameters:
     - clientId
    """
    self.send_getRouteTableByClient(clientId)
    return self.recv_getRouteTableByClient()

  def send_getRouteTableByClient(self, clientId=None):
    self._oprot.writeMessageBegin('getRouteTableByClient', TMessageType.CALL, self._seqid)
    args = getRouteTableByClient_args()
    args.clientId = clientId
    args.write(self._oprot)
    self._oprot.writeMessageEnd()
    self._oprot.trans.flush()

  def recv_getRouteTableByClient(self, ):
    (fname, mtype, rseqid) = self._iprot.readMessageBegin()
    if mtype == TMessageType.EXCEPTION:
      x = TApplicationException()
      x.read(self._iprot)
      self._iprot.readMessageEnd()
      raise x
    result = getRouteTableByClient_result()
    result.read(self._iprot)
    self._iprot.readMessageEnd()
    if result.success != None:
      return result.success
    if result.error != None:
      raise result.error
    raise TApplicationException(TApplicationException.MISSING_RESULT, "getRouteTableByClient failed: unknown result");


class Processor(Iface, TProcessor):
  _onewayMethods = ()

  def __init__(self, handler):
    TProcessor.__init__(self)
    self._handler = handler
    self._processMap = {}
    self._processMap["addUnicastRoute"] = Processor.process_addUnicastRoute
    self._processMap["deleteUnicastRoute"] = Processor.process_deleteUnicastRoute
    self._processMap["addUnicastRoutes"] = Processor.process_addUnicastRoutes
    self._processMap["deleteUnicastRoutes"] = Processor.process_deleteUnicastRoutes
    self._processMap["syncFib"] = Processor.process_syncFib
    self._processMap["periodicKeepAlive"] = Processor.process_periodicKeepAlive
    self._processMap["aliveSince"] = Processor.process_aliveSince
    self._processMap["getCounters"] = Processor.process_getCounters
    self._processMap["getRouteTableByClient"] = Processor.process_getRouteTableByClient

  def onewayMethods(self):
    l = []
    l.extend(Processor._onewayMethods)
    return tuple(l)

  @process_main()
  def process(self,): pass

  @process_method(addUnicastRoute_args, oneway=False)
  def process_addUnicastRoute(self, args, handler_ctx):
    result = addUnicastRoute_result()
    try:
      self._handler.addUnicastRoute(args.clientId, args.route)
    except PlatformError as exc0:
      self._event_handler.handlerException(handler_ctx, 'addUnicastRoute', exc0)
      result.error = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'addUnicastRoute', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(deleteUnicastRoute_args, oneway=False)
  def process_deleteUnicastRoute(self, args, handler_ctx):
    result = deleteUnicastRoute_result()
    try:
      self._handler.deleteUnicastRoute(args.clientId, args.prefix)
    except PlatformError as exc0:
      self._event_handler.handlerException(handler_ctx, 'deleteUnicastRoute', exc0)
      result.error = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'deleteUnicastRoute', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(addUnicastRoutes_args, oneway=False)
  def process_addUnicastRoutes(self, args, handler_ctx):
    result = addUnicastRoutes_result()
    try:
      self._handler.addUnicastRoutes(args.clientId, args.routes)
    except PlatformError as exc0:
      self._event_handler.handlerException(handler_ctx, 'addUnicastRoutes', exc0)
      result.error = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'addUnicastRoutes', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(deleteUnicastRoutes_args, oneway=False)
  def process_deleteUnicastRoutes(self, args, handler_ctx):
    result = deleteUnicastRoutes_result()
    try:
      self._handler.deleteUnicastRoutes(args.clientId, args.prefixes)
    except PlatformError as exc0:
      self._event_handler.handlerException(handler_ctx, 'deleteUnicastRoutes', exc0)
      result.error = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'deleteUnicastRoutes', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(syncFib_args, oneway=False)
  def process_syncFib(self, args, handler_ctx):
    result = syncFib_result()
    try:
      self._handler.syncFib(args.clientId, args.routes)
    except PlatformError as exc0:
      self._event_handler.handlerException(handler_ctx, 'syncFib', exc0)
      result.error = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'syncFib', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(periodicKeepAlive_args, oneway=False)
  def process_periodicKeepAlive(self, args, handler_ctx):
    result = periodicKeepAlive_result()
    try:
      result.success = self._handler.periodicKeepAlive(args.clientId)
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'periodicKeepAlive', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(aliveSince_args, oneway=False)
  def process_aliveSince(self, args, handler_ctx):
    result = aliveSince_result()
    try:
      result.success = self._handler.aliveSince()
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'aliveSince', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(getCounters_args, oneway=False)
  def process_getCounters(self, args, handler_ctx):
    result = getCounters_result()
    try:
      result.success = self._handler.getCounters()
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'getCounters', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(getRouteTableByClient_args, oneway=False)
  def process_getRouteTableByClient(self, args, handler_ctx):
    result = getRouteTableByClient_result()
    try:
      result.success = self._handler.getRouteTableByClient(args.clientId)
    except PlatformError as exc0:
      self._event_handler.handlerException(handler_ctx, 'getRouteTableByClient', exc0)
      result.error = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'getRouteTableByClient', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

Iface._processor_type = Processor

class ContextProcessor(ContextIface, TProcessor):
  _onewayMethods = ()

  def __init__(self, handler):
    TProcessor.__init__(self)
    self._handler = handler
    self._processMap = {}
    self._processMap["addUnicastRoute"] = ContextProcessor.process_addUnicastRoute
    self._processMap["deleteUnicastRoute"] = ContextProcessor.process_deleteUnicastRoute
    self._processMap["addUnicastRoutes"] = ContextProcessor.process_addUnicastRoutes
    self._processMap["deleteUnicastRoutes"] = ContextProcessor.process_deleteUnicastRoutes
    self._processMap["syncFib"] = ContextProcessor.process_syncFib
    self._processMap["periodicKeepAlive"] = ContextProcessor.process_periodicKeepAlive
    self._processMap["aliveSince"] = ContextProcessor.process_aliveSince
    self._processMap["getCounters"] = ContextProcessor.process_getCounters
    self._processMap["getRouteTableByClient"] = ContextProcessor.process_getRouteTableByClient

  def onewayMethods(self):
    l = []
    l.extend(ContextProcessor._onewayMethods)
    return tuple(l)

  @process_main()
  def process(self,): pass

  @process_method(addUnicastRoute_args, oneway=False)
  def process_addUnicastRoute(self, args, handler_ctx):
    result = addUnicastRoute_result()
    try:
      self._handler.addUnicastRoute(handler_ctx, args.clientId, args.route)
    except PlatformError as exc0:
      self._event_handler.handlerException(handler_ctx, 'addUnicastRoute', exc0)
      result.error = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'addUnicastRoute', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(deleteUnicastRoute_args, oneway=False)
  def process_deleteUnicastRoute(self, args, handler_ctx):
    result = deleteUnicastRoute_result()
    try:
      self._handler.deleteUnicastRoute(handler_ctx, args.clientId, args.prefix)
    except PlatformError as exc0:
      self._event_handler.handlerException(handler_ctx, 'deleteUnicastRoute', exc0)
      result.error = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'deleteUnicastRoute', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(addUnicastRoutes_args, oneway=False)
  def process_addUnicastRoutes(self, args, handler_ctx):
    result = addUnicastRoutes_result()
    try:
      self._handler.addUnicastRoutes(handler_ctx, args.clientId, args.routes)
    except PlatformError as exc0:
      self._event_handler.handlerException(handler_ctx, 'addUnicastRoutes', exc0)
      result.error = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'addUnicastRoutes', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(deleteUnicastRoutes_args, oneway=False)
  def process_deleteUnicastRoutes(self, args, handler_ctx):
    result = deleteUnicastRoutes_result()
    try:
      self._handler.deleteUnicastRoutes(handler_ctx, args.clientId, args.prefixes)
    except PlatformError as exc0:
      self._event_handler.handlerException(handler_ctx, 'deleteUnicastRoutes', exc0)
      result.error = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'deleteUnicastRoutes', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(syncFib_args, oneway=False)
  def process_syncFib(self, args, handler_ctx):
    result = syncFib_result()
    try:
      self._handler.syncFib(handler_ctx, args.clientId, args.routes)
    except PlatformError as exc0:
      self._event_handler.handlerException(handler_ctx, 'syncFib', exc0)
      result.error = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'syncFib', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(periodicKeepAlive_args, oneway=False)
  def process_periodicKeepAlive(self, args, handler_ctx):
    result = periodicKeepAlive_result()
    try:
      result.success = self._handler.periodicKeepAlive(handler_ctx, args.clientId)
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'periodicKeepAlive', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(aliveSince_args, oneway=False)
  def process_aliveSince(self, args, handler_ctx):
    result = aliveSince_result()
    try:
      result.success = self._handler.aliveSince(handler_ctx)
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'aliveSince', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(getCounters_args, oneway=False)
  def process_getCounters(self, args, handler_ctx):
    result = getCounters_result()
    try:
      result.success = self._handler.getCounters(handler_ctx)
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'getCounters', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

  @process_method(getRouteTableByClient_args, oneway=False)
  def process_getRouteTableByClient(self, args, handler_ctx):
    result = getRouteTableByClient_result()
    try:
      result.success = self._handler.getRouteTableByClient(handler_ctx, args.clientId)
    except PlatformError as exc0:
      self._event_handler.handlerException(handler_ctx, 'getRouteTableByClient', exc0)
      result.error = exc0
    except:
      ex = sys.exc_info()[1]
      self._event_handler.handlerError(handler_ctx, 'getRouteTableByClient', ex)
      result = Thrift.TApplicationException(message=str(ex))
    return result

ContextIface._processor_type = ContextProcessor

fix_spec(all_structs)
del all_structs

